<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Programming Languages Course NotesContents Chapter 1: Preliminaries Chapter 2: Evolution of Major Programming Languages Chapter 3 Describe Syntax Chapter 5: Names, Bindings, Scopes (Variables) Functio">
<meta property="og:type" content="article">
<meta property="og:title" content="Notes on Programming Languages">
<meta property="og:url" content="http://example.com/2022/10/20/Notes-on-Programming-Language/index.html">
<meta property="og:site_name" content="Benjamin Shen&#39;s Blog 沈振衣的个人主页">
<meta property="og:description" content="Programming Languages Course NotesContents Chapter 1: Preliminaries Chapter 2: Evolution of Major Programming Languages Chapter 3 Describe Syntax Chapter 5: Names, Bindings, Scopes (Variables) Functio">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-20T05:00:00.000Z">
<meta property="article:modified_time" content="2022-10-20T21:50:00.960Z">
<meta property="article:author" content="Benjamin Shen">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Notes on Programming Languages</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/BeneneeYu">Projects</a></li><!--
     --><!--
       --><li><a href="/miscs/">miscs</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/10/01/Being-smart-is-a-kind-of-knowledge/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/10/20/Notes-on-Programming-Language/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&text=Notes on Programming Languages"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&is_video=false&description=Notes on Programming Languages"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Notes on Programming Languages&body=Check out this article: http://example.com/2022/10/20/Notes-on-Programming-Language/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&name=Notes on Programming Languages&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/10/20/Notes-on-Programming-Language/&t=Notes on Programming Languages"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-Languages-Course-Notes"><span class="toc-number">1.</span> <span class="toc-text">Programming Languages Course Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Contents"><span class="toc-number">1.1.</span> <span class="toc-text">Contents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-1-Preliminaries"><span class="toc-number">1.2.</span> <span class="toc-text">Chapter 1: Preliminaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-2-Evolution-of-Major-Programming-Languages"><span class="toc-number">1.3.</span> <span class="toc-text">Chapter 2: Evolution of Major Programming Languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-3-Describe-Syntax"><span class="toc-number">1.4.</span> <span class="toc-text">Chapter 3 Describe Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-5-Names-Bindings-Scopes-Variables"><span class="toc-number">1.5.</span> <span class="toc-text">Chapter 5: Names, Bindings, Scopes (Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-Programing"><span class="toc-number">1.6.</span> <span class="toc-text">Functional Programing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Racket"><span class="toc-number">1.7.</span> <span class="toc-text">Racket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tail-Recursion"><span class="toc-number">1.8.</span> <span class="toc-text">Tail Recursion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Higher-Order-Function-aka-Functional-Form"><span class="toc-number">1.9.</span> <span class="toc-text">Higher Order Function (aka Functional Form)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture"><span class="toc-number">1.10.</span> <span class="toc-text">Lecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-6-Data-Types"><span class="toc-number">1.11.</span> <span class="toc-text">Chapter 6: Data Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prolog"><span class="toc-number">1.12.</span> <span class="toc-text">Prolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More-Prolog-Oct-21-23"><span class="toc-number">1.13.</span> <span class="toc-text">More Prolog (Oct 21 23)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More-Prolog"><span class="toc-number">1.14.</span> <span class="toc-text">More Prolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-to-Chapter-6-Pointer-and-Reference-Types"><span class="toc-number">1.15.</span> <span class="toc-text">Back to Chapter 6: Pointer and Reference Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Continue-Chapter-6"><span class="toc-number">1.16.</span> <span class="toc-text">Continue Chapter 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-7-Expressions"><span class="toc-number">1.17.</span> <span class="toc-text">Chapter 7: Expressions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-8-Statement-Level-Control"><span class="toc-number">1.18.</span> <span class="toc-text">Chapter 8: Statement Level Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-9-Subprograms"><span class="toc-number">1.19.</span> <span class="toc-text">Chapter 9: Subprograms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-10-Implementing-Subprograms"><span class="toc-number">1.20.</span> <span class="toc-text">Chapter 10: Implementing Subprograms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-10-Continue"><span class="toc-number">1.21.</span> <span class="toc-text">Chapter 10 Continue</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Notes on Programming Languages
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Benjamin Shen</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-20T05:00:00.000Z" itemprop="datePublished">2022-10-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/CS/" rel="tag">CS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Programming-Languages-Course-Notes"><a href="#Programming-Languages-Course-Notes" class="headerlink" title="Programming Languages Course Notes"></a>Programming Languages Course Notes</h2><h3 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h3><ul>
<li><a href="#chapter-1-preliminaries">Chapter 1: Preliminaries</a></li>
<li><a href="#chapter-2-evolution-of-major-programming-languages">Chapter 2: Evolution of Major Programming Languages</a></li>
<li><a href="#chapter-3-describe-syntax">Chapter 3 Describe Syntax</a></li>
<li><a href="#chapter-5-names-bindings-scopes-variables">Chapter 5: Names, Bindings, Scopes (Variables)</a></li>
<li><a href="#functional-programing">Functional Programming / Racket</a></li>
<li><a href="#chapter-6-data-types">Chapter 6: Data Types</a></li>
<li><a href="#prolog">Logical Programming / Prolog</a></li>
<li><a href="#back-to-chapter-6-pointer-and-reference-types">Back to Chapter 6: Pointer and Reference Types</a></li>
<li><a href="#chapter-7-expressions">Chapter 7: Expressions</a></li>
<li><a href="#chapter-8-statement-level-control">Chapter 8: Statement Level Control</a></li>
<li><a href="#chapter-9-subprograms">Chapter 9: Subprograms</a></li>
<li><a href="#chapter-10-implementing-subprograms">Chapter 10: Implementing Subprograms</a></li>
</ul>
<hr>
<h3 id="Chapter-1-Preliminaries"><a href="#Chapter-1-Preliminaries" class="headerlink" title="Chapter 1: Preliminaries"></a>Chapter 1: Preliminaries</h3><ul>
<li><p>Why study programming languages?</p>
<ul>
<li>improve understanding of languages you know</li>
<li>improve choice of languages for applications</li>
<li>improve ability to learn new languages</li>
<li>choose among alternative ways to express idea</li>
<li>make it easier to design new languages</li>
</ul>
</li>
<li><p>What makes a language successful?</p>
<ul>
<li>Ease of use for the novice</li>
<li>Expressive power</li>
<li>Ease of implementation, wide dissemination at minimal cost</li>
<li>Excellent compilers, possible to compile to very good (fast/small) code</li>
<li>Backing of a powerful sponsor</li>
</ul>
</li>
<li><p>Programming Domains</p>
<ul>
<li>Scientific applications <ul>
<li>large numbers of floating point computations; use of arrays</li>
<li>e.g. FORTRAN</li>
</ul>
</li>
<li>Business Applications<ul>
<li>Produce reports, use decimal number and characters</li>
<li>e.g. COBOL </li>
</ul>
</li>
<li>Artificial Intelligence <ul>
<li>Manipulate symbols rather than numbers; use of linked lists </li>
<li>e.g. LISP</li>
</ul>
</li>
<li>Web Software<ul>
<li>Eclectic collection of languages:<ul>
<li>Markup (e.g. XHTML)</li>
<li>General Purpose (e.g. Java, Kotlin, Ruby)</li>
<li>Scripting (e.g. Javascript, PHP)<ul>
<li>Scripting language - A scripting or script language is a programming language for a special run-time environment that automates the execution of tasks (e.g. python - “script”)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Domain-specific Language (DSL)</p>
<ul>
<li><em>a language specifically designed to perform tasks in a certain domain</em></li>
<li>Non-DSL examples: C, C++, COBOL, Fortan, Java<ul>
<li>They are not small</li>
<li>b.c. of their expressive power, they are not restricted to the domains each was linked to the previous slides </li>
</ul>
</li>
<li>DSL examples: CSS, SQL(Structured Query Language), UML(Unified Modeling Language)<ul>
<li>In many cases a programming can be done by a <em>domain expert</em> who is not necessarily a seasoned programmer</li>
</ul>
</li>
</ul>
</li>
<li><p>Language Evaluation Criteria</p>
<ul>
<li>Writability<ul>
<li>Simplicity and <strong><em>orthogonality</em></strong><ul>
<li>a relatively small set of <em>primitive</em> constructs</li>
<li>a <em>consistent</em> set of rules for combining them</li>
<li>every possible combination is <em>legal</em> and <em>meaningful</em></li>
<li>(orthogonal comes from math - “independence”)<ul>
<li>e.g. a single instruction (+) can use either registers or memory cells as the operands.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Support for <strong>abstraction</strong><ul>
<li>The ability to define and use complex structures of operations in ways that allow details to be ignored</li>
</ul>
</li>
</ul>
<ul>
<li>Expressivity<ul>
<li>a set of relatively convenient ways pf specifying operations</li>
<li>strength and number of operators and predefined functions</li>
</ul>
</li>
</ul>
</li>
<li>Readability<ul>
<li>Simplicity and orthogonality<ul>
<li>similar to writability</li>
</ul>
</li>
</ul>
<ul>
<li>More on simplicity<ul>
<li>Minimal feature multiplicity <ul>
<li><code>x = x + 1;</code> <code>x += 1</code> <code>x++</code> <code>++x</code> </li>
</ul>
</li>
<li>Minimal operator overloading<ul>
<li>e.g. can’t overload operator in c++</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Data Types and structures<ul>
<li>Adequate predefined data types and structures</li>
<li>e.g. C do not have a boolean type originally</li>
<li>e.g. float and double</li>
</ul>
</li>
</ul>
<ul>
<li>Syntax considerations<ul>
<li>self-descriptive constructs, meaningful keywords</li>
<li>methods of forming compound statements <code>if &#123;...&#125;</code> vs. <code>if ...endif</code></li>
</ul>
</li>
</ul>
</li>
<li>Reliability<ul>
<li>Type checking<ul>
<li>Testing for type errors, whether compile-time or run-time</li>
<li>preventing a bit-pattern representing one type of data from being interpreted as a different type of data </li>
</ul>
</li>
</ul>
<ul>
<li>Exception handling<ul>
<li>Intercept run-time errors and take corrective measures</li>
</ul>
</li>
</ul>
<ul>
<li><em>Aliasing</em> (reduce reliability)<ul>
<li>Presence of two or more distinct referencing methods for the same memory location</li>
</ul>
</li>
</ul>
<ul>
<li>Readability and writability<ul>
<li>a language that does not support “natural” ways of expressing an algorithm will require the use of “unnatural” approaches</li>
</ul>
</li>
</ul>
</li>
<li>Cost <ul>
<li>Considerations<ul>
<li>Writing programs - Closeness in purpose to the application</li>
<li>Reliability - Poor reliability leas to high costs</li>
<li>Maintaining programs</li>
</ul>
</li>
</ul>
<ul>
<li>Maintaining Duplicated Code (Cloned Code)<ul>
<li>what if there’s bug in the code clones</li>
<li>Hard for someone else to maintain</li>
</ul>
</li>
</ul>
</li>
<li>Others<ul>
<li>Portability / the ease with which programs can be moved from one implementation to another<ul>
<li>java compile once run an any java JVM - java virtual machine</li>
</ul>
</li>
</ul>
<ul>
<li>Generality / applicability to a wide range of applications</li>
<li>Well-definedness / the completeness and precision of the language’s official definition document<ul>
<li>(design compiler based on the specification)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Two Main influences on language design</p>
<ul>
<li><strong>computer architecture</strong><ul>
<li><strong>the von neumann architecture</strong> <ul>
<li>the stored-program computer</li>
<li>fetch-decode-execute</li>
<li><em>imperative languages</em> are most dominant b.c. of von Neumann computers</li>
<li>Memory is <em>separate</em> from CPU</li>
<li><em>Data</em> and <em>programs</em> both stored in memory</li>
<li>instructions/data are <em>piped</em> from memory to CPU</li>
<li>Basis for imperative languages<ul>
<li><em>Variables</em> model memory cells</li>
<li><em>Assignment statements</em> model piping</li>
<li>Efficient iterative form of repetition</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Programming Methodologies</strong><ul>
<li>New software development methodologies (e.g. object-oriented software development) led to <em>new programming paradigms</em> and by extension, new programming languages</li>
<li>1950s and early 1960s: simple applications<ul>
<li>worry about machine efficiency</li>
</ul>
</li>
<li>late 1960s: people efficiency became important<ul>
<li>structured programming; top-down design and step-wise refinement</li>
</ul>
</li>
<li>late 1970s: process-oriented to data-oriented<ul>
<li>data abstraction</li>
</ul>
</li>
<li>Middle 1980s: object-oriented programming<ul>
<li>data abstraction + inheritance + polymorphism</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Language Categories or Paradigms</p>
<ul>
<li>Language Categories<ul>
<li>Imperative<ul>
<li>Central features are variables, assignment statements, and iteration (i.e. things that <em>map directly to the hardware</em>)</li>
<li>include languages that support object-oriented programming </li>
<li>include scripting languages</li>
<li>C, C++, C#, Go, Java, Javascript, Python, Rust etc.</li>
</ul>
</li>
</ul>
<ul>
<li>Functional<ul>
<li>Main means of making computations is by <em>applying functions to given parameters</em></li>
<li>In its purest form defined as <em>mathematical functions</em>, there is no concept of memory, time or state <strong>stateless</strong></li>
<li>LISP, Clojure, Erlang, Racket, Scheme, Haskell</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/functional-programming-vs-imperative-programming">Functional Programming vs. Imperative Programming</a> </li>
</ul>
</li>
</ul>
<ul>
<li>Logic<ul>
<li>Program statements describe <em>facts</em> (e.g. “Dong is Tom’s father”) and <em>rules</em> (“If x is y’s father, and y is z’s father, then x is z’s grandfather”)</li>
<li>The computer’s job is to construct a proof based on the given axioms (<em>facts</em> + <em>rules</em>)</li>
<li>eg Prolog</li>
</ul>
</li>
</ul>
<ul>
<li>MarkUp/Programming Hybrid<ul>
<li>makeup languages extended to support some programming </li>
<li>eg HTML and JSTL, XML and XSLT</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Language Design Trade-Offs and Examples</p>
<ul>
<li>Reliability vs cost of execution<ul>
<li>Java demands all references to array elements be checked for proper indexing, which leads to increased execution costs</li>
</ul>
</li>
</ul>
<ul>
<li>Writability (flexibility) vs. reliability<ul>
<li>C and C++ pointers are powerful and very flexible, but are the source of many programming errors</li>
</ul>
</li>
</ul>
<ul>
<li>Readability vs. writability<ul>
<li>APL provides many powerful operations (and a large amount of new symbols), allowing complex computations to be written in a compact program but at the cost of poor readability</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementation Methods (1.7)</p>
<ul>
<li><strong>Compilation</strong> - Programs are <em>translated</em> into machine language<ul>
<li>Translate source program (in high-level language) into machine code</li>
<li>slow translation, fast execution (Compared to interpretation)</li>
<li>Translation occurs only once, but program is executed many times</li>
</ul>
<ul>
<li>Compilation process has phases<ul>
<li><strong>Lexical Analysis</strong> Converts characters in the source program into lexical units</li>
<li><strong>Syntax Analysis</strong> Transforms lexical units into parse tree and check syntactic correctness</li>
<li><strong>Semantic Analysis</strong> Type Checking and intermediate code generation</li>
<li><strong>Code generation</strong> machine code is generated</li>
<li>(also include other steps such as optimization when generating intermediate code)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Pure Interpretation</strong> - Programs are interpreted/executed in a <em>stepwise</em> fashion by another program known as <em>interpreter</em><ul>
<li>No translation into machine language<ul>
<li>Code is executed “on the fly”</li>
</ul>
</li>
</ul>
<ul>
<li>rare for traditional high-level languages</li>
<li>advantages<ul>
<li>execution is immediate</li>
<li>easier implementation of debugging programs<ul>
<li>But errors are not found until actually executed</li>
</ul>
</li>
</ul>
</li>
<li>disadvantages<ul>
<li>slower execution<ul>
<li>10 to 100 times slower than compiled programs</li>
</ul>
</li>
</ul>
<ul>
<li>often requires more space</li>
</ul>
</li>
</ul>
</li>
<li><strong>Hybrid Implementation Systems</strong> - A compromise between <em>compilers</em> and <em>pure interpreters</em><ul>
<li>A high-level language program is translated to an intermediate language<ul>
<li>Translation can catch many errors early</li>
</ul>
<ul>
<li>Interpreting much simpler <strong>byte code</strong></li>
</ul>
</li>
<li>Faster than pure interpretation<ul>
<li>(Byte code is really similar to machine code, but it is machine agnostic)</li>
</ul>
</li>
<li>Initial implementations of Java: the <em>byte code</em> intermediate form provides portability to machines having a byte code interpreter and a run-time system (i.e., Java Virtual Machine)</li>
</ul>
</li>
</ul>
<ul>
<li>Just-in-time implementation (wait them until they need to)<ul>
<li>The intermediate language (bytecode) of methods are translated into machine code when they become <em>hot</em> (i.e. executed more often than some <em>threshold</em>)</li>
<li>Machine code version is kept for <em>subsequent calls</em></li>
<li>E.g. source code (.java) -&gt; Java compiler -&gt; bytecode (.class) -&gt; JVM -&gt; Native Machine Code</li>
<li>eg Java, MATLAB, Python, .Net languages</li>
<li>(Note that python is an interpreted language)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-2-Evolution-of-Major-Programming-Languages"><a href="#Chapter-2-Evolution-of-Major-Programming-Languages" class="headerlink" title="Chapter 2: Evolution of Major Programming Languages"></a>Chapter 2: Evolution of Major Programming Languages</h3><ul>
<li><p>The history of languages that have had a <em>major impact</em> on the design and implementation of C++, Java, and Python, today’s leading choices for programming languages</p>
</li>
<li><p>Fortran 0 (1954) (section 2.3)</p>
<ul>
<li>1st successful high-level language </li>
<li>Computers had <em>small memories</em> and were <em>unreliable</em></li>
<li>Applications were <em>scientific</em></li>
<li><em>No</em> programming methodology or tools (from scratch)</li>
<li><em>Machine Efficiency</em> was the most important concern<ul>
<li>(focus is not on the programmer)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>was not implemented</strong></li>
</ul>
</li>
<li><p>Fortran I </p>
<ul>
<li>first <em>implemented version</em> of Fortran</li>
<li>Compiler released in April 1957 after 18 worker-years of effort</li>
<li>Outcome <ul>
<li>Programs larger than 400 lines rarely compiled correctly, mainly due to poor reliability of IBM 704</li>
<li>Code was very fast</li>
<li>Quickly became <em>widely used</em></li>
</ul>
</li>
<li>Features<ul>
<li>Post-test counting loop (do-loop)</li>
<li>Three-way selection statement<ul>
<li>Arithmetic IF - <em>if</em> (<em>expression</em>) <em>negative</em>, <em>zero</em>, <em>positive</em></li>
</ul>
</li>
</ul>
<ul>
<li>User-defined subprogram (No separate compilation)</li>
<li>Names could have up to six chars</li>
<li>No data typing statements (Types depended upon first letter of variable name)</li>
</ul>
</li>
</ul>
<ul>
<li>John W. Backus 1977 Turing Award recipient</li>
</ul>
</li>
<li><p>Fortran II, IV, and 77</p>
<ul>
<li>(earlier punch card represents a statement)</li>
<li>Fortran II<ul>
<li>distributed in 1958 - independent compilation</li>
</ul>
</li>
</ul>
<ul>
<li>Fortran IV <ul>
<li>evolved during 1960-62</li>
<li>explicit type declarations</li>
<li>legal if-statement <em>IF (ID. EQ. -9999) GO TO 76</em></li>
<li>Subprogram names could be parameters</li>
<li>ANSI standard in 1966 (Fortran 66)</li>
</ul>
</li>
</ul>
<ul>
<li>Fortran 77<ul>
<li>New standard in 1978 </li>
<li>char string handling</li>
<li>logical loop control statement </li>
<li><em>if-then-else</em> statement </li>
</ul>
</li>
</ul>
<ul>
<li>Example: Subprogram Names Passed as Parameters</li>
</ul>
</li>
<li><p>Fortran 90</p>
<ul>
<li>Changes from Fortran 77<ul>
<li>Free formatting of code</li>
<li>Modules</li>
<li>Dynamic arrays</li>
<li>Array subsection references</li>
<li>Case-statement (switch)</li>
<li>Pointers</li>
<li><strong>Recursion</strong> (no recursion makes program more efficient)</li>
<li>Parameter type checking</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Fortran Evaluation<ul>
<li>Highly optimizing compilers (all versions before 90)<ul>
<li>Types and storage of all variables are fixed before run time</li>
</ul>
</li>
</ul>
<ul>
<li>Dramatically changed forever the way computers are used</li>
<li>(Alan Jay Perlis 1966 1st Turing Award recipient)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>ALGOL</strong> - 1st step towards sophistication - section 2.5<ul>
<li>(dead)</li>
<li>Environment of development<ul>
<li>FORTRAN had (barely) arrived for IBM 70x</li>
<li>Many other languages were being developed, all for specific machines</li>
<li>No portable language; all were machine-dependent<ul>
<li>ALGOL was the result of efforts to design a <strong>universal</strong> language</li>
</ul>
</li>
</ul>
<ul>
<li>(lots of computer manufacturers in 1950s, both in US and Europe)</li>
</ul>
</li>
</ul>
</li>
<li>ALGOL 58<ul>
<li>Early design process<ul>
<li><strong>joint European-American</strong> committee met in 1958 (ACM and GAMM)</li>
<li>Goals of the language <ul>
<li>close to mathematical notation</li>
<li>good for describing algorithm</li>
<li>must be mechanically translate to machine code</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Not intended to be implemented<ul>
<li>Preliminary document for <strong>international discussion</strong></li>
<li>But variations of ALGOL 58 were (MAD, JOVIAL)<ul>
<li>(JOVIAL is the only kind of success one)</li>
</ul>
</li>
<li>IBM initially enthusiastic, but dropped support by mid-1959<ul>
<li>Adopting new programming languages was considered expensive</li>
<li>difficult to persuading programmers to try something new</li>
<li>difficult to get a “useful” first-generation compiler</li>
</ul>
</li>
</ul>
<ul>
<li>(JOVIAL is adapted by military, translated JOVIAL to C, transpiler)</li>
</ul>
</li>
<li>Language Design Features<ul>
<li>Concept of data type was formalized</li>
<li>Compound statements (begin … end)</li>
<li><em>if-statement</em> had an <em>else-if</em> clause</li>
<li>Parameters were separated by mode (passed <em>in</em> and passed <em>out</em>)<ul>
<li><code>procedure(in1, in2, in3) =: (out1, out2, out3)</code> - does not return a value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>ALGOL 60<ul>
<li>Modified ALGOL 58 at a 6-day meeting in Paris in 1960</li>
<li><strong>Peter Naur</strong> (2005 Turing Award recipient) was the main author or the paper describing ALGOL 60</li>
<li>Features:<ul>
<li>Subprogram <em>recursion</em><ul>
<li><em>New</em> for imperative languages</li>
</ul>
</li>
<li>Two parameter passing methods<ul>
<li>Pass-by-value and pass-by-name</li>
</ul>
</li>
<li>Block structure (lexical scope)<ul>
<li>Nested functions</li>
</ul>
</li>
<li>Stack storage allocation </li>
</ul>
</li>
</ul>
</li>
<li>ALGOL 60 Evaluation<ul>
<li>Successes<ul>
<li><strong>all subsequent imperative languages are based on it</strong></li>
<li>1st <strong>machine-independent</strong> language</li>
<li>1st language whose <strong>syntax was formally defined</strong> (using <strong>BNF</strong>)</li>
<li>it was the <strong>standard way to publish algorithms</strong> for over 20 years</li>
<li><strong>Robert Tarjan</strong> (1986 Turing Award recipient) <ul>
<li>an example with Robert Tarjan’s paper with the ALGOL 60 describing the algorithm</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>“showed 1st ways in which automatic computing could and should and did become a topic of academic concern” - Dijsktra (1973)</li>
</ul>
<ul>
<li>Failures<ul>
<li>Never widely used, especially in U.S.</li>
<li>Lack of I/O definition made programs non-portable</li>
<li>Too flexible - hard to implement<ul>
<li>few compilers implemented the entire language (eg pass-by-name)</li>
</ul>
</li>
</ul>
<ul>
<li>Entrenchment of Fortran / lack of support from IBM</li>
<li>Formal syntax description (BNF) seemed to complex</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>PL/I - Section 2.8<ul>
<li><strong>Everything for everybody</strong> - the first large-scale attempt to design a language that could be used for a broad spectrum of application areas</li>
<li>Background<ul>
<li>Computing Landscape in 1964 - IBM‘s point of view<ul>
<li><em>Scientific</em> computing</li>
<li><em>Business</em> computing</li>
</ul>
</li>
</ul>
<ul>
<li>By 1963<ul>
<li>Scientific users began to need more elaborate I/O</li>
<li>Business users began to need floating points and arrays</li>
</ul>
</li>
<li>The obvious solution<ul>
<li>Build a new computer to do both kinds of applications</li>
<li>Design a new language to do both kinds of applications</li>
<li>The <em>swiss army knife</em> of programing languages</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Features<ul>
<li>Unit-level concurrency</li>
<li>Exception handling</li>
</ul>
<ul>
<li>Recursion could be turned on/off (for faster execution)</li>
<li>Pointers were included as data type</li>
<li>Cross section of arrays</li>
</ul>
</li>
<li>Success<ul>
<li>Used in <strong>both</strong> business and scientific applications in the 1970s</li>
<li><strong>Instructional</strong> Vehicle in college in subset from (PL/C, PL/CS)</li>
</ul>
</li>
</ul>
<ul>
<li>Concerns<ul>
<li>Many new features were <strong>poorly designed</strong></li>
<li>too large and too complex</li>
</ul>
<ul>
<li>No reserved keywords <ul>
<li>valid syntax IF ELSE THEN ELSE = THEN; ELSE THEN = ELSE</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>ALGOL 68</strong> - section 2.11<ul>
<li>Design is based on the concept of <strong>orthogonality</strong><ul>
<li>A few basic concepts, plus a few combining mechanisms</li>
<li>eg of orthogonal 3 * (a := c + 4) + 2</li>
</ul>
</li>
</ul>
<ul>
<li>Source of several new ideas<ul>
<li>Language itself never achieved widespread use</li>
</ul>
</li>
</ul>
<ul>
<li>Features<ul>
<li>User-defined data types <code>MODE Point = STRUCT (INT x, INT y) Point t:= (1, 2)</code></li>
</ul>
<ul>
<li>Dynamic arrays (called <em>flex arrays</em>) <code>flex [1:0] INT myAry;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Pascal (1971) - <strong>Simplicity</strong> by Design - section 2.12</p>
<ul>
<li>Developed by <strong>Nikaus Wirth</strong> (1984 Turing Award) (member of ALGOL 68 committee)</li>
<li>Small and simple, widely used for teaching (mid-1970s to mid 1990s)<ul>
<li>an implementation of Pascal up and running on almost any platform in a week or so”</li>
</ul>
</li>
</ul>
<ul>
<li>Pascal compiler toolkit (need an interpreter in Assembly)<ul>
<li><em>easy to set it up</em> running b.c. how the compiler is set up</li>
<li>similar framework to Java<ul>
<li>P-Code, similar to bytecode resembling assembly language</li>
</ul>
</li>
<li>all we have to do is develop a <em>P-code Interpreter</em> for the system, <ul>
<li>Wirth gives a compiler (in p-code) -&gt; P-code Interpreter -&gt; Program (in P-code)<ul>
<li>then we can run any program in pascal code</li>
</ul>
</li>
</ul>
<ul>
<li>program(in pascal) (converted to P-code by the compiler program above) -&gt; P-code Interpreter -&gt; Program (written in Pascal now in P-code)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Features<ul>
<li>Enumeration types</li>
<li>Subrange types - create a type based on subrange of integer</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>C</strong> - A Portable Systems Language (section 2.12)</p>
<ul>
<li>Designed for systems programming (at <strong>Bell Labs</strong> by <strong>Dennis Ritchie</strong>)<ul>
<li><strong>Dennis Ritchie</strong> 1983 Turing for developing generic operating systems theory and specifically for the implementation of the UNIX os</li>
</ul>
</li>
<li>Evolved primarily from BCPL, B but also ALGOL 68</li>
<li>Rich set of operations, but poor type checking<ul>
<li>Very good for writing systems-level software (OS, etc.)</li>
</ul>
</li>
<li>Initially spread through UNIX, which included a C compiler<ul>
<li>Bootstrapping<ul>
<li>Write the C compiler in Assembly language </li>
<li>then write a C compiler in C and run through the Assembly language Compiler, and then use the C written one</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Many areas of application</li>
<li>Ken Thompson (also developer of C) also developed Go</li>
</ul>
</li>
<li><p><strong>Smalltalk</strong> - object-oriented programming(section 2.15)</p>
<ul>
<li>developed at Xerox PARC in 1970’s, by <strong>Alan Kay</strong>(Turing Award 2003), then Adele Goldberg</li>
<li>First full implementation of an <strong>object-oriented programming</strong> (data abstraction, inheritance, and dynamic binding)</li>
<li>also pioneered the <strong>graphical user interface design</strong> </li>
<li>promoted Object-Oriented Programming (OOP)</li>
</ul>
</li>
<li><p><strong>C++</strong> - Combining Imperative and OO Programming (section 2.16)</p>
<ul>
<li>Developed at Bell Labs by <strong>Bjarne Stroustrup</strong> in 1980</li>
<li>Evolved from C and <strong>SIMULA 67</strong><ul>
<li>Facilities for OOP taken partially from SIMULA 67</li>
</ul>
</li>
</ul>
<ul>
<li>A large and complex language, in part because <strong>it supports both procedural and OOP</strong></li>
<li>Rapidly grew in popularity along with OOP</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Java</strong> - Imperative-Based OO Language Section 2.17<ul>
<li>Developed at Sun (became oracle later) in the early 1990s<ul>
<li>C and C++ were not satisfactory for <strong>embedded electronic devices</strong></li>
</ul>
</li>
</ul>
<ul>
<li>Based on C++<ul>
<li>Significantly <strong>simplified</strong> (does not include struct, union, pointer arithmetic, and half of the assignment <em>coercions</em> of C++)</li>
<li>supports <strong>only OOP</strong></li>
<li>has references, but not pointers</li>
<li>Garbage collected memory management</li>
</ul>
</li>
</ul>
<ul>
<li>Evaluation<ul>
<li>Eliminated many unsafe features of C++</li>
<li><strong>Portable</strong>: Java Virtual Machine concept, JIT compilers</li>
<li>Use increased faster than any previous language<ul>
<li>Mostly due to academic <strong>acceptance</strong> and <strong>support</strong> from certain corporations (<em>anti-Microsoft</em> by IBM, Sun, and Netspace communications)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-3-Describe-Syntax"><a href="#Chapter-3-Describe-Syntax" class="headerlink" title="Chapter 3 Describe Syntax"></a>Chapter 3 Describe Syntax</h3><ul>
<li>section 3.1 - 3.3 </li>
<li>intro<ul>
<li><strong>Syntax</strong> - the form of <strong>structure</strong> of the expressions, statements, and program units</li>
<li><strong>Semantics</strong> - the <strong>meaning</strong> of the expressions, statements, and program units</li>
<li>Syntax and semantics provide a language’s <em>definition</em></li>
<li>Language Definition Users<ul>
<li>Initial evaluators (the language designers)</li>
<li>Implementers (the compiler writers)</li>
<li>Programmers (the users of the language)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Review Compilation<ul>
<li>Lexical Analysis - converts characters in the source program into lexical units</li>
<li>Syntax Analysis - transforms lexical units into parse tree and check syntactic correctness</li>
</ul>
</li>
</ul>
<ul>
<li>Lexical Analysis<ul>
<li>source code -&gt; long string of ASCII characters</li>
<li>The lexical analyzer splits it into <strong><em>tokens</em></strong></li>
<li><strong>TOKEN</strong><ul>
<li>a syntactic category that forms a class of <strong><em>lexemes</em></strong> </li>
<li>identifiers, literals, keywords, operators, punctuation</li>
</ul>
</li>
</ul>
<ul>
<li><strong>LEXEME</strong><ul>
<li>a sequence of characters that matches the pattern for a token<ul>
<li>myVariable 123 5.67 true char public + - * / l, {}</li>
<li><em>instances</em> of tokens/classes</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Whitespace (exception: Python) and comments discarded</li>
<li>Detecting Code Clones After Lexical Analysis <ul>
<li>spread the original source code through lexical analysis to lexmmes</li>
<li>ignoring lexeme values</li>
<li>identifying duplicate sequences </li>
<li>Detected clones - back to the original code block associated with the lexmmes</li>
<li>ccfiner.net use this approach to detect clones</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Describing syntax<ul>
<li>(syntax can be right, though semantically might not be)</li>
<li>Meta-language<ul>
<li>a language used to define other languages</li>
</ul>
</li>
</ul>
<ul>
<li>Grammar <ul>
<li>a meta-language used to defined the <em>syntax</em> of a language</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Formal Definition of Languages</p>
<ul>
<li><em>recognizers</em> <ul>
<li>a <em>recognition device</em> reads input strings over the alphabet of the language and decided whether the input strings to the language</li>
<li>produces a <em>yes/no</em> answer as to whether the input string in a valid sentence in th language<ul>
<li>or whether the given file contains a valid program for the programming language</li>
</ul>
</li>
</ul>
<ul>
<li>example: syntax analysis part of a compiler</li>
</ul>
</li>
<li><em>Generators</em><ul>
<li>a device that generates valid sentences of a language </li>
<li>generates a random sentence each time</li>
<li>thus limited use as a language descriptor</li>
<li>one can determine the syntax of a particular sentence is syntactically correct by <em>comparing</em> it to the <em>structure of the generator</em><ul>
<li>compilers are often created by <em>specifying a generator description</em> that is then <em>used to create a recognizer</em></li>
<li>much of this forms the basis of <em>computational theory</em> </li>
</ul>
</li>
</ul>
</li>
<li><strong>Language generator -&gt; language -&gt; language recognizer</strong></li>
</ul>
</li>
<li><p>BNF and context-free grammars (developed independently)</p>
<ul>
<li>developed Noam Chomsky (a linguist)</li>
<li>four classes of <em>generative devices</em> of <em>grammars</em> that define four classes of languages</li>
<li>two of them (<em>context-free</em> and <em>regular</em>) were later useful for describing the syntax of programming languages<ul>
<li>regular - tokens, context-free - syntax analyzer</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Backus-Naur Form</strong> (1959)</p>
<ul>
<li>Invented by John Backus to describe <strong>Algol 58</strong><ul>
<li>introduced Peter Naur’s contributions while describing <strong>Algol 60</strong></li>
</ul>
</li>
<li>A natural notation for describing syntax</li>
<li>BNF is equivalent to context-free grammars</li>
</ul>
</li>
<li><p>A BNF grammar consist of </p>
<ul>
<li>start symbol, fine set of production rules, finite set of terminal symbols, fine set of nonterminal symbols</li>
<li>example of BNF production Rules (going from left to right)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;while_loop&gt; -&gt; while (&lt;logic_expr&gt;) &lt;stmt&gt;</span><br><span class="line">&lt;if_stmt&gt; -&gt; if (&lt;logic_expr) then &lt;stmt&gt;</span><br></pre></td></tr></table></figure></li>
<li><em>Terminals</em> are Lexemes or tokens (eg while(), if() then)</li>
<li><em>Nonterminal symbols</em> are abstractions used to represent classes of syntactic structures (<code>&lt;while_loop&gt;</code>, <code>&lt;logic_expr&gt;</code>, <code>&lt;stmt&gt;</code>) (consists of terminals in the leaves)<ul>
<li>Nonterminals are often enclosed in angle brackets</li>
</ul>
</li>
<li>a <em>production rules</em> has <ul>
<li>a LHS, which is a single <em>nonterminal</em>, and</li>
<li>a RHS, which is a string of <em>terminals</em> and/or <em>nonterminals</em></li>
</ul>
</li>
</ul>
<ul>
<li>A <em>derivation</em> is the <strong>repeated application of rules</strong>, starting with the <em>start symbol</em> (a special nonterminal) and ending with a <em>sentence</em> (a string of <strong>only</strong> terminal symbols)<ul>
<li>start symbol - (derivation / Repeated application of rules) -&gt; sentence (a string of only terminal symbols)</li>
</ul>
</li>
</ul>
</li>
<li><p>BNF Rules</p>
<ul>
<li>An abstraction (or nonterminal symbol) can have more than one RHS (eg using <code>|</code> to separate)</li>
</ul>
</li>
<li><p>Describing Lists</p>
<ul>
<li>Syntactic lists are described using <em>recursion</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;stmt_list&gt; -&gt; &lt;stmt&gt; </span><br><span class="line">    | &lt;stmt&gt;; &lt;stmt_list&gt; &#x2F;&#x2F; lists</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Derivations</p>
<ul>
<li><strong>Sentential form</strong> - Every string of (non terminal or terminal) symbols in a derivation <ul>
<li>The bottom one is also called <strong>sentence</strong> e.g. a = c + 2</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Leftmost Derivation</strong></p>
<ul>
<li>The <em>leftmost nonterminal</em> in each sentential form is the one that is expanded next</li>
</ul>
<ul>
<li>(opposite - rightmost Derivation)</li>
</ul>
</li>
<li><p><strong>Parse Tree</strong></p>
<ul>
<li>A hierarchical representation of a derivation</li>
</ul>
</li>
<li><p>Ambiguity in Grammars</p>
<ul>
<li>A grammar is <em>ambiguous</em> if and only if it generates a sentential form that has two more meanings</li>
<li>e.g. operator precedence </li>
</ul>
</li>
<li><p>An <strong>Unambiguous</strong> Expression Grammar</p>
<ul>
<li>use the parse tree to indicate precedence levels of the operators<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; -&gt; &lt;expr&gt; - &lt;term&gt; | &lt;term&gt;</span><br><span class="line">&lt;term&gt; -&gt; &lt;term&gt; &#x2F; const | const</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Associativity of Operators</p>
<ul>
<li>Operator associativity can also be indicated by a grammar<ul>
<li>eg <code>&lt;expr&gt; -&gt; &lt;expr&gt; + &lt;expr&gt; | const</code></li>
</ul>
</li>
</ul>
<ul>
<li><strong>unambiguous</strong> <code>&lt;expr&gt; -&gt; &lt;expr&gt; + const | const</code></li>
<li>parenthesis ? <code>expr</code> -&gt; <code>term</code> -&gt; <code>factor</code> -&gt; (<code>expr</code>) (finish up at very bottom)</li>
</ul>
</li>
</ul>
<ul>
<li>when we do the expansion: One expansion at a time (leftmost mostly)</li>
<li>Note about associativity</li>
</ul>
<ul>
<li>The “Dangling Else” Problem<ul>
<li>if-then-else ambiguity<ul>
<li>if <logic_expr> then if <logic_expr> else <stmt></stmt></logic_expr></logic_expr></li>
<li>else should be associated with the closest if</li>
</ul>
</li>
<li>unambiguous way<ul>
<li>idea: <matched> cannot be an if-statement without an else-part<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;stmt&gt; -&gt; &lt;matched&gt; | &lt;unmatched&gt; </span><br><span class="line">&lt;matched&gt; -&gt; if &lt;logic_expr&gt; then &lt;matched&gt; else &lt;matched&gt;</span><br><span class="line">          | &lt;all other non IF statements&gt;</span><br><span class="line">&lt;unmatched&gt; -&gt; if &lt;logic_expr&gt; then &lt;stmt&gt;</span><br><span class="line">          | if &lt;logic_expr&gt; then &lt;matched&gt; else &lt;unmatched&gt; </span><br></pre></td></tr></table></figure></matched></li>
</ul>
</li>
</ul>
</li>
<li>Solving the Dangling Else Ambiguity<ul>
<li>Associate each <em>else-part</em> with closest <em>if-part</em></li>
<li>To override: <ul>
<li>Use: {…} or begin … end<ul>
<li>C/C++, Go (must have the brackets), Java, Javascript, Kotlin, OCaml</li>
</ul>
</li>
</ul>
<ul>
<li>Use an explicit delimiter to end every conditional (e.g., if … end if)<ul>
<li>Ada Julia MATLA PHP Ruby</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Extended BNF (EBNF)<ul>
<li>Write grammar easier/simpler way</li>
<li>become the standard way to define languages</li>
<li>introduced by <em>Niklaus Wirth</em> (Pascal)</li>
<li>Optional parts are placed in brackets []<ul>
<li><code>&lt;pro_call&gt;</code> -&gt; <ident> ( [<expr_list>])</expr_list></ident></li>
</ul>
</li>
</ul>
<ul>
<li>Alternative parts of RHS are placed inside parentheses and separated via vertical bars <ul>
<li><code>&lt;term&gt;</code> -&gt; <code>&lt;term&gt;</code> (+|-) const</li>
</ul>
</li>
</ul>
<ul>
<li>Repetitions (0 or more) are placed inside braces{}<ul>
<li><code>&lt;identifier_list&gt;</code> -&gt; <code>&lt;identifier&gt;</code> {, <code>&lt;identifier</code>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; -&gt; &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">        | &lt;expr&gt; - &lt;term&gt; </span><br><span class="line">        | &lt;term&gt;</span><br><span class="line">&lt;term&gt; -&gt; &lt;term&gt; * &lt;factor&gt; </span><br><span class="line">        | &lt;term&gt; &#x2F; &lt;factor&gt; </span><br><span class="line">        | &lt;factor&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; -&gt; &lt;term&gt; &#123;(+|-) &lt;term&gt;&#125;</span><br><span class="line">&lt;term&gt; -&gt; &lt;factor&gt; &#123;(*|&#x2F;) &lt;factor&gt;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-5-Names-Bindings-Scopes-Variables"><a href="#Chapter-5-Names-Bindings-Scopes-Variables" class="headerlink" title="Chapter 5: Names, Bindings, Scopes (Variables)"></a>Chapter 5: Names, Bindings, Scopes (Variables)</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Sections 5.1 - 5.4</li>
<li>Intro<ul>
<li><em>Imperative languages</em> are <em>abstractions</em> of <em>Von Neumann architecture</em></li>
<li><em>Variables</em> are the abstraction of <em>memory shells</em></li>
<li>Variables are characters by attributes</li>
<li>To design data types of a language ,must consider <em>scope and lifetime</em> of variables, <em>type checking</em>, <em>initialization</em>, and <em>type compatibility</em> </li>
</ul>
</li>
</ul>
<ul>
<li>Attributes of Variables<ul>
<li>Name, Address, Type, Value, Lifetime, Scope</li>
</ul>
</li>
</ul>
<ul>
<li>Attributes of Variables - <strong>Name</strong><ul>
<li>Case sensitivity <ul>
<li>most languages are case sensitive (C-based languages like C++ and java)</li>
<li>Case insensitive languages (Ada, Fortran, Pascal, SQL)</li>
</ul>
</li>
</ul>
<ul>
<li>Related Notes<ul>
<li>“Case sensitive names reduces <em>readability</em>“<ul>
<li>Somewhat alleviated by <em>naming conventions</em> (eg variables always start a lowercase letter)</li>
</ul>
</li>
</ul>
<ul>
<li>Naming conventions (style) mostly for the <em>human reader</em><ul>
<li><em>Semantically</em> meaningful capitalization exists (Go requires accessible functions in packages start with uppercase letter; will see Prolog later)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Keywords and reserved words<ul>
<li><em>reserved word</em> - a special word that can’t be used as a user-defined name</li>
<li><em>keyword</em> - a word that is special <em>only</em> in certain contexts</li>
<li>However, we often use “reserved word” and “keyword” interchangeably </li>
</ul>
</li>
</ul>
<ul>
<li>Related notes<ul>
<li>no reserved words (PL/I)</li>
<li>many reserved words (~300 COBOL)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Attributes of Variables - <strong>Address</strong><ul>
<li>The memory address with which a variable is associated to<ul>
<li>a variable may have different addresses at different times during execution</li>
</ul>
</li>
</ul>
<ul>
<li>sometimes referred to <em>L-value</em><ul>
<li>at least by compiler writers</li>
</ul>
</li>
<li>Aliases<ul>
<li>if two or more variable names have to access the same memory location</li>
</ul>
<ul>
<li>bad for readability - program reader must remember all of them</li>
<li>created via pointers, reference variables, C and C++ unions, Fortran EQUIVALENCE</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Attributes of Variables - <strong>Type</strong><ul>
<li>Determines the <em>range of values</em> of variables and <em>set of operations</em> that are defined for values of that type</li>
</ul>
</li>
</ul>
<ul>
<li>Attributes of Variables - <strong>value</strong><ul>
<li>the <em>contents</em> of the location with which the variable is associated </li>
<li>sometimes referred to as <em>R-value</em> of a variable</li>
</ul>
</li>
</ul>
<ul>
<li>The concept of binding<ul>
<li>a <em>binding</em> is an association, such as between an attribute and an entity (e.g. a variable and its type), or between an operation and a symbol</li>
<li><em>Binding time</em> is the time at which a binding takes place</li>
</ul>
</li>
<li>Possible Binding Times <ul>
<li>PL design time<ul>
<li>The design of specific program, constructs (syntax), primitive types, and meaning (semantics)</li>
<li>bind operation symbols to operations, i.e. “+” to addition </li>
</ul>
</li>
<li>PL implementation time<ul>
<li>fixation of numeric precision, maximum identifier name length, types of built-in exceptions, etc.  </li>
<li>Bind floating point type to a representation (e.g., IEEE 754)</li>
</ul>
</li>
<li>Compile time<ul>
<li>translation of high-level constructs to machine code</li>
<li>Bind a variable to a data type in C or Java</li>
</ul>
</li>
</ul>
<ul>
<li>Load Time<ul>
<li>time when the operating system loads the executable in memory</li>
<li>Bind a C or C++ <em>static</em> variable to a memory cell</li>
</ul>
</li>
<li>Runtime<ul>
<li>time when the program executes (runs)</li>
<li>bind a non-static local variable to a memory cell</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Types of binding<ul>
<li><strong>Static binding</strong> - bindings that first occur before run time <em>and</em> remains unchanged throughout program execution (compile time)</li>
<li><strong>Dynamic binding</strong> - bindings that first occur during execution <em>or</em> can change during execution of the program (run time)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Static Type Binding</strong><ul>
<li>Explicit declaration<ul>
<li>Type information supplied in source code</li>
<li>standard “run of the mill” declaration such as <code>int x</code></li>
<li>C, C++, Java</li>
</ul>
</li>
<li>Implicit declaration<ul>
<li>Type specification through default conventions, rather than explicit declarations</li>
<li>Good for Writ-ability - don’t need to provide explicit declaration</li>
<li>FORTRAN (depends on the first letter), Perl</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Type Inferencing</strong><ul>
<li>A form of implicit type declaration</li>
<li>static typing without having to declare explicit types</li>
<li>C++, Go, Java, Kotlin</li>
</ul>
</li>
</ul>
</li>
<li><strong>Dynamic Type Binding</strong><ul>
<li>The variable is bound to a type when it is assigned a value in an assignment statement</li>
</ul>
<ul>
<li>Good for Flexibility - generic program units</li>
<li>bad, high cost - run-time type checking and interpretation rather than compilation</li>
</ul>
<ul>
<li>JavaScript, LISP, MATLAB, PHP, <strong>Python</strong>, Ruby</li>
</ul>
</li>
</ul>
<ul>
<li>Storage Bindings and Lifetimes <ul>
<li>A key characteristic of imperative programming languages is storage bindings and the lifetime of its variables</li>
<li>Storage Bindings<ul>
<li><em>allocation</em> - getting a cell from some pool of available cells</li>
<li><em>deallocation</em> - putting a cell back into the pool</li>
</ul>
</li>
</ul>
<ul>
<li>Lifetime <ul>
<li>the <strong>lifetime</strong> of a variable is the time during which it is bound to a particular memory cell</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Categories of variables by <strong>lifetimes</strong><ul>
<li>Static</li>
<li>Stack-dynamic</li>
<li>Explicit heap-dynamic</li>
<li>Implicit heap-dynamic</li>
<li><strong>Static variables</strong><ul>
<li>bound to memory cells <em>before execution begins</em> and remains bound to the same memory cell <em>throughout execution</em></li>
</ul>
<ul>
<li>C and C++ <strong>static variables</strong>, all variables in FORTRAN 77</li>
<li>advantages / disadvantages<ul>
<li>good for efficiency (direct addressing), globally accessible, history-sensitive subprogram support<ul>
<li>history-sensitive ‘persistent variable’ would assign x as  available depends on what the previous calls are </li>
</ul>
</li>
<li>bad for lack of flexibility (no recursion), no shared storage<ul>
<li>eg x y 1000 element array, if they are static, we can’t share resources between them</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>static-dynamic</strong><ul>
<li>storage bindings are created for variables when their declaration statements are <em>elaborated</em> (i.e., when the executable code associated with it is executed)</li>
<li>Good: allows recursion; conserves storage</li>
<li>bad: overhead of allocation and deallocation, subprograms not history-sensitive, inefficient references (indirect addressing)<ul>
<li>stack pointer</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Explicit Heap-dynamic variables</strong><ul>
<li><em>allocated</em> and <em>deallocated</em> by explicit directives, specified by the <em>programmer</em>, which take effect during execution</li>
<li>dynamic objects in C++ (via <em>new</em> and <em>delete</em>), all objects in Java</li>
<li>good - provides for dynamic storage management</li>
<li>bad - inefficient (indirect addressing), unreliable (error prone), complex storage management implementation</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Implicit Heap-Dynamic Variables</strong><ul>
<li>allocation and deallocation caused by assignment statements</li>
<li>all var in LISP, all strings and arrays in JavaScipt, Perl and PHP</li>
<li>Good - flexibility (generic code)</li>
<li>bad - inefficient (all attributes are dynamic)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Read section 5.5-5.8</li>
<li>Scope<ul>
<li>the <strong>scope</strong> of a variable is the range of statements in which it is visible (i.e. can be referenced)<ul>
<li>mostly interested in the scope rules for <em>nonlocal variables</em> of a program unit are those that are visible, bit not declared there</li>
<li>Lifetime tell us <em>how long something exists</em>, scope tells us <em>who can access it</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Types of Scope<ul>
<li><strong>static scope</strong> - based on the program text</li>
<li><strong>dynamic scope</strong> - based on calling sequences of program units</li>
</ul>
</li>
</ul>
<ul>
<li>static scope aka lexical scope<ul>
<li> to connect a name reference to a variable, you (or the compiler) must <em>find the declaration</em></li>
<li> based on program text can be determined by <em>human reading the code</em></li>
</ul>
</li>
</ul>
<ul>
<li>Searching for nonlocal variables<ul>
<li>search process<ul>
<li>search declarations, first locally then in increasingly larger enclosing scopes, until one is found for the given name</li>
</ul>
</li>
</ul>
<ul>
<li>Related Terms<ul>
<li>enclosing static scopes (to a specific scope) are called its <em>static ancestors</em></li>
<li>the nearest static ancestor is called a static parent<ul>
<li>static ancestors</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Nested subprograms<ul>
<li>some languages allow nested subprogram definitions, which create nested static scope</li>
<li>Ada, Fortran 2003, JS, Pascal, PHP, Python</li>
<li><strong>C-based languages</strong> do not allow nested subprograms (including java)</li>
</ul>
</li>
</ul>
<ul>
<li>Blocks<ul>
<li>method to create static scopes inside program units (from ALGOL 60)</li>
<li>create <em>stack-dynamic</em> variables<ul>
<li>such variables typically have small scopes (easy to reason about)</li>
<li><code>int count = ...; while(..) &#123;int count = ...&#125;</code> declare legal in c and c++, but not in java or c# (<code>while() &#123; int count &#125; int count</code> legal in java, since first count is in the block and out of scope when we meet the second count)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Declaration order<ul>
<li>C99, C++, Java: The scope of all variables is from the declaration to the <em>end of the block</em></li>
<li>C# (more script):<ul>
<li>The scope of any variable declared in a block is the whole block, <em>regardless</em> of the position of the declaration in the block</li>
<li>However, a variable still must be declared before it can be used </li>
<li>java - below, C# - neither above nor below, <code>while() &#123; int count &#125; int count</code> not legal in any part of the nested scope, good for readability</li>
</ul>
</li>
<li>Javascript, scope is from declaration to the end of program<ul>
<li>“closure”<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">program</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>var key word would gives 20 in both print statements</li>
</ul>
</li>
<li>Go, rust, Kotlin(run keyword) are working just like C++</li>
</ul>
</li>
</ul>
<ul>
<li>static scope example<ul>
<li>a function can call anything in, <strong>along-side</strong>, and above it; see anything in and above it; but can’t call and see anything inside other functions</li>
</ul>
</li>
</ul>
<ul>
<li>advantages of static scoping<ul>
<li>works well in most situations</li>
<li>programs are easy to reason about/read (<em>critical</em>)</li>
</ul>
</li>
</ul>
<ul>
<li>disadvantages<ul>
<li>in many cases, too much access is possible</li>
<li>want variables to be accessed <em>only</em> where needed</li>
<li>As a program evolves, the initial structure is destroyed and local variables often become global; subprograms also gravitate toward becoming global, rather than nested</li>
</ul>
</li>
</ul>
<ul>
<li>Dynamic scope<ul>
<li>references to nonlocal variables are connected to declarations by search back through the <em>chain of subprogram calls</em> that forced execution to this point</li>
<li>APL, SNOOL4, LISP(early versions)</li>
<li>dynamic scoping has disappeared from recent programing languages</li>
<li>the exception is <em>exception handling</em>; which essentially uses dynamic scoping to associate a handler with an exception</li>
<li>advantages: <ul>
<li><em>convenience</em> - the called subprogram is executed in the context of the caller</li>
</ul>
</li>
</ul>
<ul>
<li>disadvantages<ul>
<li><em>poor readability</em> - programs are difficult to reason about</li>
<li>No static type checking (type checking can still be done but must be done dynamically)</li>
<li>all variables from caller are visible to called subprogram</li>
</ul>
</li>
</ul>
</li>
<li>Referencing Environments<ul>
<li>The <em>referencing environment</em> of a statement is the collection of all names that are visible at the statement</li>
</ul>
<ul>
<li>Static-scoped language<ul>
<li>the local variables <em>plus</em></li>
<li>all visible variables in all of the enclosing scopes (or static ancestors)</li>
</ul>
</li>
</ul>
<ul>
<li>Dynamic-scope language<ul>
<li>the local variables <em>plus</em></li>
<li>all visible variables in all active subprograms</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Functional-Programing"><a href="#Functional-Programing" class="headerlink" title="Functional Programing"></a>Functional Programing</h3><ul>
<li>project 1 - recursion - <strong>backtrack</strong></li>
<li>2.4, 15.1 - 15.6, 16.11</li>
<li>we will explore racket, scheme which what racket based on, clojure has similar syntax</li>
<li>Quotes on LISP (First Functional PL)<ul>
<li>Small talk designer Alan Kay “greatest programming language”</li>
</ul>
</li>
</ul>
<ul>
<li>imperative languages<ul>
<li>based: <em>Von Neumann architecture</em></li>
<li>Efficiency is the program concern</li>
<li>state represented by variables</li>
</ul>
</li>
</ul>
<ul>
<li>Functional languages<ul>
<li>based: <em>mathematical functions</em></li>
<li>solid theoretical basis, also close to the user</li>
<li><strong>no variables or state!</strong> (no identifiers)</li>
</ul>
</li>
</ul>
<ul>
<li>LISP began as pure-functional, but gained some imperative features</li>
<li>Simple <em>Mathematical</em> Function<ul>
<li>Every parameter of a function is bound to a values and remains constant through evaluation</li>
<li>No such thing as a variable that models a memory location</li>
</ul>
<ul>
<li>(No side effects, not dependent on external values, no concept of state)</li>
</ul>
</li>
<li>A simple function<ul>
<li>LAMBBDA/lambda expression<ul>
<li>nameless</li>
</ul>
</li>
</ul>
<ul>
<li>Passing parameters<ul>
<li>Lambda expressions are <em>applied to parameters</em> by placing parameter(s) after the expression</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Functional Form - higher order functions<ul>
<li>lambda expressions are also handy for <em>creating functions to pass as parameters</em> to other functions that expect to receive functions<ul>
<li>lambda expressions introduced in c++11 and Java 8</li>
</ul>
</li>
<li>a second property is these functions can return other functions</li>
</ul>
</li>
</ul>
<ul>
<li>Function Form - Composition<ul>
<li>takes two functions as input and returns a new function</li>
<li>the returned function is the result of the first function applied to the second</li>
<li>h = f circle g means h = f(g(x))</li>
</ul>
</li>
</ul>
<ul>
<li>Comparing functional and imperative<ul>
<li>execution: imperative more efficient</li>
<li>syntax: functional is more simple</li>
<li>semantics: function is simple</li>
<li>concurrency: imperative programmer designed hard, functional programs can automatically be made concurrent<ul>
<li>functions are independent, easy to parallelize</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Racket"><a href="#Racket" class="headerlink" title="Racket"></a>Racket</h3><ul>
<li>LISP (list processing) history<ul>
<li>developed 1958 - 59 for use in AI programming<ul>
<li>designed at MIT by John McCarthy</li>
<li>Based on <em>lambda calculus</em>; mathematical functions</li>
</ul>
</li>
</ul>
<ul>
<li>FORTRAN unsatisfactory for AI<ul>
<li>needed recursion</li>
<li>desired to manipulate symbols rather than numbers</li>
<li>process data in lists rather than arrays</li>
</ul>
</li>
</ul>
<ul>
<li><em>interpreted</em> not compiled</li>
<li>garbage collection (no explicit freeing)</li>
</ul>
</li>
<li>LISP Data Types and structures<ul>
<li><em>data object types</em>: originally only atoms and lists</li>
<li><em>list form</em>: parenthesized collection of atoms and/or sublists</li>
<li>Noe that the type of x is bound at run time (“late binding”)<ul>
<li><code>(define x 5.0) ; x is a double</code></li>
<li><code>(define x&#39;(5)); x is a list</code> </li>
<li>Note: these are names not variables</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>LISP interpretation<ul>
<li><em>Functions definitions</em>, <em>function applications</em>, and <em>data</em> all have the same form</li>
<li>list (A B C) <ul>
<li>interpreted as data is a simple <em>list of three atoms</em></li>
<li>interpreted as a function application, <em>function named</em> A is <em>applied</em> to the two parameters, B and C.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>LISP syntax<ul>
<li>A series of <em>symbolic expressions</em> (or <em>S-expressions</em>) contain atom and list</li>
<li>Atom - symbol (sequence of characters) or number (Integer, float, ratio of integers)<ul>
<li>ratio allows us to maintain accuracy with integer division operations</li>
</ul>
</li>
<li>List <ul>
<li>() or nil</li>
<li>(S-expression)</li>
<li>(S-expression, S-expression, …) - recursive definition (<em>S-expressions</em> are defined in terms of <em>lists</em> which are defined in terms of <em>S-expression</em> which … )</li>
</ul>
</li>
</ul>
</li>
<li>LISP Lists<ul>
<li>LISP lists are stored internally as single-linked lists</li>
</ul>
</li>
</ul>
<ul>
<li>Lisp Semantics - Function call<ul>
<li>The first <em>S-expression</em> in a list is the name of a functional</li>
<li><code>(foo) ; call function foo</code></li>
<li><code>(foo a b c) ; call function foo with arguments a, b, and c, in that order</code></li>
</ul>
<ul>
<li>all arguments are evaluated first, then the function is applied to the results</li>
<li>Prefix (Polish) notation (or Cambridge Polish Notation)</li>
</ul>
<ul>
<li><code>++i</code> is <code>(add+ i)</code> in racket; no side effect, i still the original value, couldn’t change the value of i</li>
<li>eg (* (* (* 2 2) 2) 2)arguments are evaluated before the * is applied</li>
<li>there are a free functions (called <em>special form</em>) that don’t evaluate their arguments</li>
</ul>
</li>
</ul>
<ul>
<li>Scheme<ul>
<li>a mid-1970s dialect of LISP, designed to be a cleaner, more modern and simpler version than the contemporary dialects of LISP</li>
<li>uses only static scoping </li>
<li>function are <em>first-class</em> entities<ul>
<li>they can be <em>values of expressions</em>, <em>elements of lists</em>, <em>passed as parameters</em>, and <em>returned from functions</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Racket vs Scheme<ul>
<li>scheme and racket are very similar languages</li>
</ul>
<ul>
<li>racket “changed its name” in 2010</li>
<li>a modern language used to build some real-word systems</li>
</ul>
</li>
</ul>
<ul>
<li>The racket interpreter<ul>
<li>in interactive mode, the Racket interpreter is an infinite <em>read-evaluate-print-loop</em> (REPL)</li>
<li>This form of interpreter is also used by python and ruby</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Function Evaluation<ul>
<li>Parameters are evaluated, <em>in no particular order</em><ul>
<li><code>(foo (goo a) (hoo a)</code> doesn’t matter in functional programming, matters in imperative</li>
</ul>
</li>
<li>the values of the parameters are substituted into the function body</li>
<li>the function body is evaluated</li>
<li>the value of <em>last expression in the body</em> is the value of the function</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive and numeric predicate functions<ul>
<li>Primitive arithmetic functions<ul>
<li>+-*/, abs, sqrt, modulo, (or reminder), min max</li>
</ul>
</li>
<li>numeric predicate functions<ul>
<li>#T (or #t) is true and #F (or #f) is false</li>
<li>=, &gt;, &lt; , &gt;=, &lt;=</li>
<li>EQUAL?, EVEN?, ODD?, ZERO?, NEGATIVE?, NUMBER?</li>
<li><em>not</em> function inverts the logic of a boolean expression</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Special form functions: Lambda Expressions<ul>
<li><em>Lambda expressions</em> describe nameless or anonymous functions</li>
</ul>
<ul>
<li>form is based on lambda notation (lambda, then parameters, then body)</li>
<li><code>(lambda (x) (*x x))</code> defines a procedure (not calling it)<ul>
<li><code>x</code> is called a bound variable</li>
</ul>
</li>
<li>lambda expressions can be applied to parameters<ul>
<li>to call the procedure we have <code>( (lambda (x) (*x x) 3 )</code> yields 9</li>
</ul>
</li>
<li>lambda expressions can have any number of parameters<ul>
<li><code>(lambda (a b x) ( + (* a x x)(* b x)))</code></li>
</ul>
</li>
</ul>
</li>
<li>Special form functions: <code>define</code><ol>
<li>to bind a symbol to an expression<ul>
<li><code>(define pi 3.141593)</code></li>
</ul>
<ul>
<li><code>(define two-pi (*2 pi)</code></li>
</ul>
</li>
<li>to bind names to lambda expressions (LAMBDA is implicit)<ul>
<li><code>(define pyth (lambda (a b) (sqrt (+ (* a a ) (* b b) ))))</code><ul>
<li><code>(define (pyth2 a b) (sqrt (+ (* a a) (* b b))))</code> takes out the lambda expression</li>
</ul>
</li>
<li><code>(pyth 3 4)</code></li>
</ul>
</li>
</ol>
<ul>
<li>In both cases, the <em>evaluation</em> process for <em>define</em> is different!<ul>
<li>the first parameter is never evaluated</li>
<li>The second parameter is evaluated and bound to the first parameter</li>
</ul>
</li>
</ul>
</li>
<li>Special Form Functions: if<ul>
<li>two-way selector function (IF)</li>
<li>Syntax: (if <em>predicate</em> <em>then_exp</em> <em>else_exp</em>)</li>
<li>else is required</li>
</ul>
</li>
</ul>
<ul>
<li>special form functions: cond<ul>
<li>general form of a call to <em>cond</em><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cond</span></span><br><span class="line">  (<span class="name">predicate1</span> expression1)</span><br><span class="line">  (<span class="name">predicate2</span> expression2)</span><br><span class="line">  ...</span><br><span class="line">  (<span class="name">else</span> expression) // not required</span><br><span class="line">  // displayln (<span class="name">functionname</span> param) returns #&lt;void&gt; which means return nothing</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>semantics: the value of the evaluation of <code>cond</code> is the value of the expression associated with the <em>first predicate expression that is true</em>, where predicates are evaluated one at a time until one is true</li>
</ul>
</li>
</ul>
<ul>
<li>Parenthesis or Brackets<ul>
<li>interchangeable</li>
<li>common style to use […] to enclose predicate-expression in a <em>cond</em> function</li>
</ul>
</li>
</ul>
<ul>
<li>Programming Style<ul>
<li>Racket Coding Style<ul>
<li>Multi-word names separated by dashes (not camel case)</li>
<li>ending parenthesis should not be in their line</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>List Functions: <strong>quote</strong></p>
<ul>
<li>the <strong>quote</strong> function takes one parameter and returns the parameter <em>without evaluation</em><ul>
<li>‘(A B) is equivalent to (quote (A B))</li>
</ul>
</li>
<li>required because the interpreter (named <strong>EVAL</strong>) <em>always</em> evaluates parameters to function applications before applying the function</li>
</ul>
</li>
<li><p>car, cdr</p>
<ul>
<li>the <strong>car</strong> function returns the first element of its list parameter</li>
<li>the <strong>cdr</strong> function returns the remainder of its list parameter after the first element has been removed</li>
</ul>
</li>
<li><p>Cons</p>
<ul>
<li>uses the <strong>con</strong> function to add a new head to the front of a list</li>
<li><code>(cons &#39;a &#39;(b c))</code></li>
<li>The <strong>cons</strong> function makes a new list by inserting its first argument (after evaluation) onto the front of the list which its second argument (after evaluation)</li>
<li>it creates a new node at the front of the linked list (called a <em>cons cell</em>)</li>
<li>a copy of the second argument is <strong>not</strong> made</li>
<li><code>(cons &#39;A &#39;B) &#39;(A dot B)</code> dotted pair</li>
</ul>
</li>
</ul>
<ul>
<li>List functions: <strong>list null? list?</strong><ul>
<li>list function returns a new list of its parameters<ul>
<li><code>(list &#39;A &#39;B &#39;(C D)&#39;)</code> gives <code>&#39;(A B (C D))</code></li>
</ul>
</li>
</ul>
<ul>
<li>null function tests an empty list<ul>
<li><code>(null? &#39;()&#39;)</code> or <code>(null? null)</code> gives #t</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>contractions<ul>
<li><code>(cadr lst)</code> equivalent to <code>(car (cdr lst))</code> gives the second element of a list</li>
</ul>
</li>
</ul>
<ul>
<li>List Processing<ul>
<li>Lists are a natural recursive structure<ul>
<li>either they are empty</li>
<li>or they contain a head element followed by another list</li>
</ul>
</li>
</ul>
<ul>
<li>thus it is natural to write recursive functions to process lists</li>
</ul>
</li>
</ul>
<ul>
<li>List functions: <strong>append</strong><ul>
<li>the append constructs a new list that contains all elements of the <em>two given list arguments</em><ul>
<li>different from the list function</li>
<li><code>(append &#39;(a b) &#39;(c d))</code> result from list function would be ((a b) (c d))</li>
<li>the parameters <em>must</em> be lists<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define (append list1 list2))</span><br><span class="line">  (cond</span><br><span class="line">    [(null? list1) list2]</span><br><span class="line">    [else </span><br><span class="line">      (cons (car list1) (append (cdr list1) list2))]))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Parenthesis: why it is good?</p>
<ul>
<li>by parenthesizing everything, converting the program text into a tree representing the program (parsing) is <em>trivial and unambiguous</em><ul>
<li>atoms are leaves</li>
<li>sequences are nodes with elements as children</li>
<li>(no other rules)</li>
</ul>
</li>
</ul>
<ul>
<li>makes indention easy</li>
</ul>
</li>
<li><p>recursive functions</p>
<ul>
<li>process the head of a list, recurse down the list, base case is an empty list</li>
</ul>
<ul>
<li>return a value, should not be inside a parenthesis, or it would be interpreted as a function call</li>
<li>deep recursion - also recurse down any sublists</li>
</ul>
</li>
<li><p>Implementing equal function (deep recursion)</p>
<ul>
<li><code>eq</code> works for atom, <code>equal</code> most generic <code>eqv</code> in between <code>=</code> for numeric value<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(define equal list 1 list2</span><br><span class="line">    (cond</span><br><span class="line">        ; predicate             ; return value</span><br><span class="line">        [(not (list? list1))    (eq? list1 list2)]</span><br><span class="line">        [(not (list? list2))    #f]</span><br><span class="line">        ; both params are lists</span><br><span class="line">        [(null? list1)          (null? list2)]</span><br><span class="line">        [(null? list2)          #f]</span><br><span class="line">        [(equal (car list1) (car list2))    (equal (cdr list1) (cdr list2))]</span><br><span class="line">        [else                   #f]))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Racket Local binding <code>LET</code> <code>LET*</code> <code>LETREC</code> <code>DEFINE</code></p>
<ul>
<li>Variety is good; They have <em>different semantics</em><ul>
<li>use the one most convenient for your needs, which helps communicate your intent to people reading your code</li>
<li><em>if any will work</em> use <strong>let</strong></li>
</ul>
</li>
<li>help us better learn scope and environments</li>
<li>the three kinds of let-expressions can appear anywhere</li>
</ul>
</li>
<li><p>Let</p>
<ul>
<li>A <em>let-expression</em> can bind any number of local bindings<ul>
<li>Notice where all the parentheses are</li>
<li><code>(let () ())</code></li>
<li>in the example both x in let based from the first x</li>
<li>convention: binding use bracket</li>
<li>can only use parameters</li>
<li>let is actually a short hand for a lambda expression applied to a parameter<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(define (silly-double x)</span><br><span class="line">  (let ([x (+ x 3)]</span><br><span class="line">        [y (+ x 2)])</span><br><span class="line">     (+ x y - 5)))</span><br><span class="line"></span><br><span class="line">(define (silly-double x)</span><br><span class="line">  (lambda (x y) (+ x y - 5) (+ x 3) (+ x 2)))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>the expressions are all evaluated in the environment from <strong><em>before the let-expression</em></strong></li>
</ul>
</li>
<li><p>let*</p>
<ul>
<li>the expressions are evaluated in the environment produced from the <strong>previous binding</strong><ul>
<li>can repeat bindings (later ones shadow)</li>
<li>following bindings can use previous bindings</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>letrec (for recursion)<ul>
<li>Syntactically a <code>letrec</code> expression is also the same</li>
</ul>
<ul>
<li>needed for recursion / mutual recursion</li>
<li>bindings variables can quote each other</li>
<li>But expressions are still <strong>evaluated in order</strong>: accessing an uninitialized binding would produce an error<ul>
<li>would be bad style and a bug</li>
<li>remember function bodies not evaluated until called</li>
</ul>
</li>
<li>in the example, f lambda is evaluated until later<ul>
<li>not legal in lec or lec*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define (silly-triple x)</span><br><span class="line">  (letrec ([y (+ x 2)]</span><br><span class="line">           [f (lambda (z) (+ z y w x))]</span><br><span class="line">           [w (+ x 7)])</span><br><span class="line">           (f -9)))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>what if x was defined in the letrec environment?  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (silly-triple x)</span><br><span class="line">  (letrec ([y (+ x 2)]</span><br><span class="line">           [f (lambda (z) (+ z y w x))]</span><br><span class="line">           [w (+ x 7)]</span><br><span class="line">           [x 100])</span><br><span class="line">           (f -9)))</span><br></pre></td></tr></table></figure>
<ul>
<li>which x is used in the bindings if y, f, and w?<ul>
<li>it will be the x defined in the letrec environment</li>
<li>however, the function will produce an error, because the definition of x is after the definition of y (which needed the value bound to x)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Letrec vs Local Defines<ul>
<li>in certain positions, like the beginning of function bodies, you can put nested defines<ul>
<li>for beginning local bindings, same semestics as letrec<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(define (silly-mod2 x)</span><br><span class="line">  (letrec</span><br><span class="line">    ([my-even? (lambda (x) (if (zero? x) #t (my-odd? (- x 1))))]</span><br><span class="line">     [my-odd? (lambda (x) (if (zero? x) #f (my-even? (- x 1))))])</span><br><span class="line">       (if (my-even? x) 0 1)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(define (silly-mod2 x)</span><br><span class="line">  (define (my-even? x) (if (zero? x) #t (my-odd? (-x 1))))</span><br><span class="line">  (define (my-odd? x) (if (zero? x) #f (my-even? (-x 1))))</span><br><span class="line">  (if (my-even? x) 0 1)))</span><br></pre></td></tr></table></figure>
<h3 id="Tail-Recursion"><a href="#Tail-Recursion" class="headerlink" title="Tail Recursion"></a>Tail Recursion</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>tail recursion increases efficiency <ul>
<li>there is nothing to do after the function returns except return its value</li>
</ul>
</li>
<li>A tail recursive function can be <em>automatically</em> converted by a compiler to use iteration, making it faster</li>
<li>original recursion<ul>
<li>each call must wait for the result of calling itself in order to multiple with n<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (fact n)</span><br><span class="line">  (if (&lt;&#x3D; n 0) </span><br><span class="line">    1</span><br><span class="line">    (* n fact(- n 1)))))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>tail recursive <ul>
<li>‘<strong>accumulator</strong>‘</li>
<li>each call is actually done with its “work” once it calls itself again<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(define (fact n)</span><br><span class="line">  (define (helper n acc)</span><br><span class="line">    (if (&lt;&#x3D; n 0) </span><br><span class="line">      acc</span><br><span class="line">      (helper (- n 1) (*n acc)))</span><br><span class="line">  )</span><br><span class="line">  (helper n 1))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>begin (printf(…) .. ..) (return value)</li>
<li>(time func) gives time</li>
<li>(define lst (range 1000000)) gives a list of the given val</li>
</ul>
<h3 id="Higher-Order-Function-aka-Functional-Form"><a href="#Higher-Order-Function-aka-Functional-Form" class="headerlink" title="Higher Order Function (aka Functional Form)"></a>Higher Order Function (aka Functional Form)</h3><ul>
<li>Review<ul>
<li>(&gt;50% code writing)</li>
<li>Chpt 1</li>
<li>Chpt 2 (multiple choice) for history (low percentage)</li>
<li>Chpt 3 another derivation (parse tree)<ul>
<li>ambiguous - multiple parse tree</li>
</ul>
</li>
<li>Chpt 5 variables</li>
<li>Chpt 15 Racket<ul>
<li><code>car</code> <code>cdr</code> <code>cons</code> <code>list</code> <code>append</code></li>
</ul>
</li>
</ul>
</li>
<li>A function that either take one or more <em>functions</em> as parameters or yields <em>function</em> as its result, or both</li>
<li>Functional parameters <ul>
<li>consider a member function that tells us if an item exists in a list</li>
</ul>
<ul>
<li>change equal to &lt; or &gt;?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define (my-member2 test x lst)</span><br><span class="line">  (cond</span><br><span class="line">    [(null? lst) #f]</span><br><span class="line">    [(test x (car lst)) #t] ; testing function passed as parameter </span><br><span class="line">    [else (my-member2 test x (cdr lst))]))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Review: functional form - <strong>composition</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (g x) (* 3 x))</span><br><span class="line">(define (f x) (+ x 2))</span><br><span class="line">(define (h x) (g (h x)))</span><br><span class="line">(define (h x) (+ (* 3 x) 2))</span><br></pre></td></tr></table></figure></li>
<li>The <strong><em>compose</em></strong> function  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (compose func1 func2) (lambda (x) (func1 (func2 x))))</span><br><span class="line">(define h (compose f g))</span><br><span class="line">(define (cadr lst) ((compose car cdr) lst))</span><br><span class="line"></span><br><span class="line">(define (third lst)</span><br><span class="line">  ((compose car (compose cdr cdr)) lst)) ; same as caddr</span><br></pre></td></tr></table></figure></li>
<li>The <strong><em>filter</em></strong> function<ul>
<li>takes a <em>predicate function</em> as its first param, often in form of lambda expression</li>
<li>returns a <em>list</em> with those items from the param list that <em>satisfy the predicate</em></li>
</ul>
</li>
<li>The <strong><em>map</em></strong> function<ul>
<li>higher-order function that:<ul>
<li>Takes two parameters <em>a function</em> and <em>list(s)</em></li>
<li>Applies the function to <em>each element</em> of the list and returns a <em>list of results</em></li>
<li>eg. <code>(map cube &#39;(1 3 5))</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (map fun lst)</span><br><span class="line">  (if (null? lst)</span><br><span class="line">    &#39;()</span><br><span class="line">    (cons (fun (car lst)) (map fun (cdr lst)))))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>real built-in map is more powerful and general<ul>
<li>e.g. <code>(map max &#39;(1 2 3) &#39;(0 5 42))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>The <strong><em>foldr</em></strong> function (right fold)<ul>
<li>get a <strong>single result</strong> by combining all elements by applying a binary operation - this is known as <em>reduction</em> or <em>fold</em></li>
<li><code>foldr f b &#39;(x1 x2 ... xn))</code> (b is the default val)</li>
<li>returns <code>(f x1 (f x2 ... (f xn b) ...))</code> or bb if a list is empty</li>
<li><em>sum reduction</em> <code>(define (sumr lst) (foldr + 0 lst))</code><ul>
<li><code>(foldr cons &#39;() &#39;(1 2 3 4))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>map and reduce<ul>
<li>these functions that take functional parameters create are extremely powerful programing abstraction</li>
<li>many cloud computing initiatives are built on these two simple concepts</li>
<li>Do a Google search on <em>MapReduce</em> or its open source counterpart <em>Hadoop</em></li>
</ul>
</li>
<li>map and reduce example<ul>
<li>Using <em>foldl</em> or <em>foldr</em> and <em>map</em>, find the sum of a list where each positive numer is doubled first</li>
</ul>
</li>
</ul>
<h3 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h3><ul>
<li>Lambda: the Great and powerful<ul>
<li>These abilities(<em>creating nameless functions on the fly via lambda</em>, and <em>passing around functional parameters</em>) are a very powerful programming concept</li>
<li>They are so powerful, that imperative and OOP languages have added those abilities</li>
<li>Both C++11 and Java 8 include lambda expressions and better handling of functional parameters</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Thunks</strong><ul>
<li>functional languages do interesting things with their first-class functions</li>
<li>one trick is to <em>delay the evaluation</em> of an expression by wrapping it in a <em>parameter-less function</em></li>
<li>Such a function is called a <em>thunk</em><ul>
<li>it captures the expression and the environment in which it was defined</li>
<li>calling the function later will evaluate the expression in its original environment to produce the desired value</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Eager Evaluation<ul>
<li>eager evaluation<ul>
<li>in racket, java, and C, <em>function arguments</em> are evaluated once before calling the function</li>
</ul>
</li>
</ul>
<ul>
<li>lazy evaluation<ul>
<li>For <em>conditionals</em>, the condition is eagerly evaluated, but the branches are not</li>
</ul>
</li>
</ul>
<ul>
<li>it matters, calling <code>factorial-bad</code> never terminates:<ul>
<li>when we get to n = 0, we always have to evaluate z before we pass it in the my-if-bad function, hence eval fact-bad with -1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (my-if-bad x y z) (if x y z))</span><br><span class="line"></span><br><span class="line">(define (fact-bad n)</span><br><span class="line">  (my-if-bad (&#x3D; n 0) 1 (* n (fact-bad ( - n 1)))))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Use Thunks to Delay<ul>
<li>we know how to delay evaluation: put expression in a function!</li>
<li>A zero-argument function used to delay evaluation is called a <em>thunk</em><ul>
<li>as a verb: thunk the expression<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; GOOD WAY make y z a function</span><br><span class="line">; don&#39;t execute the function, use parenthesis to execute it</span><br><span class="line">; one way of delayed expression</span><br><span class="line">(define (my-if-strange-but-works x y z) (if x (y) (z))</span><br><span class="line"></span><br><span class="line">(define (fact-good n)</span><br><span class="line">  (my-if-strange-but-works (&#x3D; n 0) </span><br><span class="line">    (lambda () 1)</span><br><span class="line">    (lambda () (* n (fact-good ( - n 1))))))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>The key point<ul>
<li>evaluate an expression to get a result: <code>e</code></li>
<li>a function that when called, evaluates e and returns result: <code>(lambda () e)</code><ul>
<li>zero-argument function for “thunking”</li>
</ul>
</li>
</ul>
<ul>
<li>Evaluate e to some thunk and then call the thunk: (e)</li>
<li>powerful idioms related to delaying evaluation and/or avoided repeated or unnecessary computations<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; thunk</span><br><span class="line">(define e (+ 3 4))</span><br><span class="line">; couldn&#39;t put e inside a parenthesis, e is a value but not a function</span><br><span class="line">(define f (lambda () e))</span><br><span class="line">; call f</span><br><span class="line">(f)</span><br><span class="line">; we don&#39;t get e until we get f, thunk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Streams</strong>   <ul>
<li>one interesting application of thunks in the creation of <em>streams</em></li>
<li>a stream is an <em>infinite sequence of values</em><ul>
<li>we cannot generate all the values ahead of time (the sequence is infinite)</li>
<li>but we can generate the values as they are needed</li>
<li>key idea: use a <em>thunk</em> to delay creating most of the sequence</li>
</ul>
</li>
</ul>
<ul>
<li>A powerful concept for division of labor<ul>
<li>Stream <em>producer</em> knows how to create any number of values</li>
<li>Stream <em>consumer</em> decides how many values to ask for</li>
</ul>
</li>
<li>Let a stream be a <strong>thunk</strong> that <em>when called</em> returns a pair: <code>&#39;(next-answer . next thunk)</code></li>
<li>so given a stream s, the client get any number of elements</li>
</ul>
<ul>
<li>first: <code>(car (s))</code></li>
<li>second: <code>(car ((cdr(s))))</code></li>
<li>third <code>(car ((cdr ((cdr(s))))))</code></li>
<li>Note that the thunk needs to be called separately when getting its car or cdr<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(define powers-of-two</span><br><span class="line">    (letrec ([f (lambda (x)     ; 2) When the thunk is called, ... </span><br><span class="line">      (cons                     ; 3) it returns a pair, where ...</span><br><span class="line">       x                        ; 4) the _car_ is the stream&#39;s next value, ...</span><br><span class="line">       (lambda () (f (* x 2)))))])  ; 5) and the _cdr_ is a thunk that can give the rest of the values of the stream.</span><br><span class="line"></span><br><span class="line">       (lambda () (f 2))))      ; 1) The powers-of-two stream is a thunk.</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>now let’s write a stream function <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(define (stream-nth str n)</span><br><span class="line">  (let ([pr (str)])              ; Bind the pair that is the result of calling the stream to pr.</span><br><span class="line">  (if (zero? n)                  ; If n is zero, ...</span><br><span class="line">    (car pr)                     ; return the _car_ of the pair.</span><br><span class="line">    (stream-nth (cdr pr) (- n 1)))))        ; Otherwise, call the function recursively, ...</span><br><span class="line">; passing the _cdr_ of the pair (a thunk) and n decremented by one.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>Functions that build code<ul>
<li>eval function<ul>
<li>it is possible in racket to define a function that builds racket code request its interpretation</li>
<li>this is possible because the interpreter is a user-available function: eval<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (adder lst)</span><br><span class="line">  (cond</span><br><span class="line">    [(null? lst) 0]</span><br><span class="line">    [else (eval (cons &#39;+ lst))]))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>the parameter is a list of numbers to be added</li>
<li>A + operations is added to to the front of the original list and is evaluated<ul>
<li>use cons to the insert the atom + into the list of numbers</li>
<li>be sure that + is quoted to prevent evaluation</li>
<li>submit the new list to eval for evaluation</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-6-Data-Types"><a href="#Chapter-6-Data-Types" class="headerlink" title="Chapter 6: Data Types"></a>Chapter 6: Data Types</h3><ul>
<li>chpt 6</li>
<li>introduction<ul>
<li>Data Type<ul>
<li>defines a set of <em>possible values</em> (the domain), together with a number of <em>pre-defined</em> operations</li>
<li>defines how to <em>interpret bit strings</em> of various lengths</li>
<li>allow compiler / runtime system to detect misuse (<em>type checking</em>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Data Types<ul>
<li>those not defined in terms of another data types</li>
<li>almost all PL provide a set pf <em>primitive data types</em></li>
<li>(corresponding hardware representation)</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive data Types: Integer<ul>
<li><em>almost always</em> an exact reflection of hardware so mapping is trivial</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Data Types: Floating point<ul>
<li>model real numbers, but only as approximations    <ul>
<li>sign, exponent + fraction</li>
</ul>
</li>
<li>IEEE Float-Point Standard 754</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Data Types: complex<ul>
<li>the complex type consists of two floats, the real part and the imaginary part<ul>
<li>Fortran, MATLAB, Python</li>
</ul>
<ul>
<li>in Python: (7+ 3j), where 7 is the real part and 3 is the imaginary part</li>
</ul>
</li>
</ul>
</li>
<li>Primitive Data Types: Decimal<ul>
<li>Stored a fixed number of decimal digits, in coded form called binary code decimal (BCD) where each digit is encoded separately, 4 bits/digit</li>
<li>good accuracy<ul>
<li>eg 0.1 in BCD: 0.0001 (but will be infinite in floating point)</li>
</ul>
</li>
<li>bad limited range, wastes memory, not all CPUs have direct hardware support</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Data Types; Decimal<ul>
<li>for business applications (representing money)<ul>
<li>COBOL, C#</li>
<li>eg C# double type is the typical floating point type, and C# decimal type is(smaller range)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive data types: boolean<ul>
<li>simplest of all: two elements</li>
<li>could be implemented as bit, but often as a byte</li>
<li>good for readability in logic expressions (as opposed to interpreting numeric expressions)</li>
</ul>
</li>
</ul>
<ul>
<li>Primitive Data Types: Character<ul>
<li>Stored as numeric codings</li>
<li>ASCII <ul>
<li>7 bit character set</li>
<li>inadequate in the WWW era</li>
</ul>
</li>
</ul>
<ul>
<li>unicode<ul>
<li>initially fixed 16-bit (UCS-2)</li>
<li>includes the base multilingual plane</li>
<li>still inadequate, UTF-8 (variable length) is now more widely used<ul>
<li>backward compatible to ASCI</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>number of bytes <ul>
<li>number of bytes 1, 7 bits for code point<ul>
<li>Byte 1 0xxxxxxx</li>
</ul>
</li>
<li>number of bytes 2, 11 bits for code point<ul>
<li>110xxxxx 10xxxxx (add 10 b.c. don’t want to be end of the string)</li>
</ul>
</li>
<li>number of bytes 3, 16 bits for code point<ul>
<li>1110xxxx 10xxxxxx 10xxxxxx</li>
</ul>
</li>
<li>number of bytes 4, 21 bits for code point<ul>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</li>
</ul>
</li>
</ul>
</li>
<li>Phaistos Disk (nobody knows what it means, but it’s in <em>Unicode</em>)</li>
</ul>
</li>
<li>Character String Types: Length Options / Implementation<ul>
<li>Static Length</li>
<li>Limited Dynamic Length</li>
<li>Dynamic Length</li>
</ul>
</li>
</ul>
<ul>
<li>Static Length<ul>
<li>Ada Using package <code>Ada.Strings.Fixed</code><ul>
<li>str1 : string(1..4);</li>
<li>str1 : string(1..4)</li>
</ul>
</li>
</ul>
<ul>
<li>Java <ul>
<li>Text includes Java’s String class, but may not be determined until runtime</li>
</ul>
</li>
</ul>
<ul>
<li>compile-time descriptor<ul>
<li>static string</li>
<li>length</li>
<li>address</li>
<li>(how to read a descriptor: <em>top row</em> identifies the descriptor type, <em>the other rows</em> are the data of the descriptor (attributes))</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Descriptors</strong><ul>
<li>a collection of the <em>attributes of a variable</em></li>
<li>can be <em>static or dynamic</em></li>
<li><strong>static</strong> descriptor maintained by the compiler (e.g. C++ variable information)</li>
<li><strong>Dynamic</strong> descriptors managed at runtime (e.g. Lisp or Python variable information)</li>
</ul>
</li>
</ul>
<ul>
<li>Limited Dynamic Length<ul>
<li>(string doesn’t have to be that much)</li>
<li>Ada - Using package Ada.Strings.Bounded</li>
<li>c - text includes c-style strings, but run-time descriptor isn’t needed because of null terminator and no range checking</li>
<li>Run-time Descriptor<ul>
<li>Limited Dynamic String</li>
<li>Maximum length</li>
<li>current length</li>
<li>address</li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Length<ul>
<li>unbounded</li>
<li>ada - rule specific - using package Ada.Strings.Unbounded</li>
<li>C++ standard Library, JavaScript Perl</li>
</ul>
</li>
</ul>
<ul>
<li>Ordinal Types<ul>
<li>A type in which the range of possible values can be easily associated with the <em>set of positive integers</em></li>
<li>Primitive Ordinal Types in Java<ul>
<li>integer, char, boolean</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Enumeration Types<ul>
<li>A <em>user defined</em> <strong>ordinal</strong> type</li>
<li>all possible values, which are named constants, are provided in the definition</li>
</ul>
</li>
</ul>
<ul>
<li>Evaluation of enumerated Type<ul>
<li>Good, no need to code a color as a number (readability)</li>
<li>Good, Compiler perform checks (reliability)<ul>
<li>operations (don’t allow colors to be added)</li>
<li>no enumeration variable can be assigned a value outside its defined range</li>
<li>Ada, C#, and Java 5.0 provide better support for enumeration than C++, because enumeration type variables in these languages are not coerced into integer types </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Array Types</strong><ul>
<li>an array is an aggregate of <em>homogeneous data</em> elements in which an individual elements <em>is identified by its position in the aggregate</em>, relative to the first element</li>
</ul>
</li>
</ul>
<ul>
<li><p>Array Indexing</p>
<ul>
<li><em>indexing</em> (or subscripting) is a mapping from indices to elements</li>
<li>Parentheses ()<ul>
<li>Ada explicitly chose parentheses to show uniformity between array references and functions call because both are <em>mappings</em><ul>
<li>bad for readability</li>
<li>Ada, Fortran, Matlab, PL/L</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>most other languages - Brackets[]<ul>
<li>brackets allow the compiler to disambiguate the construct earlier in the compilation process</li>
</ul>
</li>
</ul>
</li>
<li><p>Index range checking</p>
<ul>
<li>by default, C#, Go, Java</li>
<li>not at all: c, c++, FORTRAN</li>
<li>on demand: Ada</li>
</ul>
</li>
<li><p>Subscript Binding and Array Categories</p>
<ul>
<li>Static<ul>
<li>subscript ranges are statically bound and storage allocations static (before run-time)</li>
<li>Good Efficiency (no dynamic allocation/deallocation)</li>
<li>C and C++ arrays that include <code>static</code> modifier</li>
</ul>
</li>
</ul>
<ul>
<li>Fixed Stack-Dynamic<ul>
<li>subscript ranges are statically bound, but the allocation done at declaration elaboration time</li>
<li>Good space efficiency</li>
<li>C and C++ arrays without <code>static</code> modifier are fixed stack-dynamic</li>
</ul>
</li>
</ul>
<ul>
<li>Fixed Heap-Dynamic<ul>
<li>similar to fixed stack-dynamic: fixed after allocation, but storage binding is dynamic (i.e., binding is done when requested at runtime)</li>
<li>C, C++, Java (new operator) (Java array are auto)</li>
</ul>
</li>
</ul>
<ul>
<li>Heap-dynamic<ul>
<li>binding of subscript ranges and storage allocation is dynamic can change any number of times</li>
<li>Good for <em>flexibility</em> (arrays can grow or shrink during program execution)</li>
<li>C# (class list), JavaScript, Perl, Python, Ruby</li>
</ul>
</li>
</ul>
</li>
<li><p>Homogeneous Arrays</p>
<ul>
<li>A <em>heterogeneous array</em> is one in which the elements need not be of the same type</li>
<li>JavaScript, Perl, Python, Ruby</li>
<li>in all cases, the arrays are <em>heap-dynamic</em></li>
<li>most likely the arrays elements only contain <em>references</em> to the data that is stored in the array</li>
</ul>
</li>
<li><p>Array operations</p>
<ul>
<li><em>Array operations</em> are those that operate on the array as a single unit</li>
<li>Elemental Operations<ul>
<li>operations between pairs of array elements</li>
<li>For example, + operator between two array results in an array of the sums of the element pairs of two array<ul>
<li>APL, Fortran 95, MATLAB</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Catenation<ul>
<li><ul>
<li>operator between two arrays results in the concatenation of the two arrays</li>
</ul>
</li>
<li>Ada, python</li>
</ul>
</li>
</ul>
</li>
<li><p>Multi-dimensional Arrays</p>
<ul>
<li>Rectangular Array<ul>
<li>Multi-dimensioned array where <em>all rows</em> have the <em>same number of elements</em> and <em>all columns</em> have the <em>same number of elements</em></li>
<li>Ada, C#, FORTRAN, MATLAB</li>
</ul>
</li>
</ul>
<ul>
<li>Jagged Array<ul>
<li>Multi-dimensional array where rows can have <em>varying number of elements (arrays of arrays)</em></li>
<li>C, C++, C#, Java, JavaScript</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementation of Arrays</p>
<ul>
<li>Access function maps subscript expressions to an address in the array</li>
<li>Access function for single-dimensioned arrays:<ul>
<li><code>address(arr[k]) = address(arr[lower_bound]) + ((k - lower_bound) * element_size)</code></li>
</ul>
<ul>
<li>lower_bound is zero in many languages, though Fortran uses one</li>
</ul>
</li>
</ul>
</li>
<li><p>Locating an Element in a Multi-dimensioned Array</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address(a[i, j]) &#x3D; </span><br><span class="line">    address(a[row_lb, col_lb])</span><br><span class="line">    + ( ((i - row_lb) * n)</span><br><span class="line">         + (j - col_lb) )</span><br><span class="line">    * element_size</span><br></pre></td></tr></table></figure></li>
<li><p>Accessing Multi-dimensional Arrays</p>
<ul>
<li>Storing Arrays in Memory<ul>
<li><em>Row-major</em> order (used in most languages)</li>
<li><em>Column-major</em> order (Fortran, MATLAB)</li>
</ul>
</li>
</ul>
<ul>
<li>Importance of knowing array layout in memory<ul>
<li>it can greatly affect your speed of your code</li>
<li>let’s try out a sample<ul>
<li>C++ (row-major)</li>
<li>MATLAB (column-major), note preallocation array make computation faster</li>
</ul>
</li>
<li>what happened? cache miss and page swapping</li>
</ul>
</li>
</ul>
</li>
<li><p>Review: Descriptors</p>
<ul>
<li>Single-dimensioned array<ul>
<li>Array, Element type, index lower bound, index upper bound, address</li>
</ul>
</li>
</ul>
<ul>
<li>Multi-dimensional array<ul>
<li>Multi-dim array, element type, index type, number of dimensions, Index range 1, …, index range n, address</li>
</ul>
</li>
</ul>
</li>
<li><p>Associative Arrays</p>
<ul>
<li>An <strong>unordered</strong> collection of data elements that are indexed by an equal number of values called <em>keys</em></li>
<li>properties<ul>
<li>Maps <em>arbitrary</em> indices to values</li>
<li>Elements are essentially <em>keys and value pairs</em></li>
<li>often implemented as <em>hash tables</em></li>
</ul>
</li>
</ul>
<ul>
<li>language<ul>
<li>Python -&gt; <em>dictionaries</em> (value and keys can be all different types)</li>
<li>Perl -&gt; <em>hashes</em></li>
<li>Java -&gt; use <em>Map</em></li>
</ul>
</li>
</ul>
</li>
<li><p>Composite Types (Book: Record Type)</p>
<ul>
<li>An aggregate of possibly <em>heterogeneous</em> data elements in which individual elements are <em>identified by names</em></li>
<li>composite types go by many names<ul>
<li>struct, C/C++, Go</li>
<li>record, Ada, Pascal</li>
<li>named tuple, Python</li>
<li>data class: Kotlin</li>
</ul>
</li>
</ul>
<ul>
<li>Object-orientation: from a data point of view, classes also define composite types</li>
</ul>
</li>
</ul>
<ul>
<li>Definition of Records in COBOL<ul>
<li>COBOL uses level numbers to show nested records; others use recursive definitions<ul>
<li>Referencing record elements, or <em>fields</em>, is usually by name rather than by index<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">01 EMP-REC.</span><br><span class="line">    02 EMP-NAME.</span><br><span class="line">        05 FIRST PIC X(20).</span><br><span class="line">        05 MID   PIC X(10).</span><br><span class="line">        05 LAST  PIC X(20).</span><br><span class="line">    02 HOURLY-RATE PIC 99V99.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>43 percent or banking systems are built on COBOL</li>
</ul>
</li>
</ul>
<ul>
<li>Definition of Records in Ada<ul>
<li>Record structures are indicated in an orthogonal way<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Emp_Name_Type is record</span><br><span class="line">    First: String (1..20);</span><br><span class="line">    Mid: String (1..10);</span><br><span class="line">    Last: String (1..20);</span><br><span class="line">end record;</span><br><span class="line"></span><br><span class="line">type Emp_Rec_Type is record</span><br><span class="line">    Emp_Name: Emp_Name_Type;</span><br><span class="line">    Hourly_Rate: Float;</span><br><span class="line">end record;</span><br><span class="line"></span><br><span class="line">Emp_Rec: Emp_Rec_Type;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>References to Records<ul>
<li>Record field references:<ul>
<li>COBOL: (inmost-out)<ul>
<li><em>field_name</em> OF <em>record_name_n</em> OF .. OF <em>record_name_1</em></li>
<li>e.g. <code>FIRST OF EMP-NAME OF EMP-REC</code></li>
</ul>
</li>
<li>Others(dot notation):(outmost-in)<ul>
<li>record_name_1.record_name_2. … record_name_n.field_name</li>
<li><code>Emp_Rec.Emp_Name.First</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Fully qualified references must include all record names </li>
</ul>
<ul>
<li><em>Elliptical references</em> allow leaving out record names as long as the reference is unambiguous<ul>
<li>For example, in COBOL: FIRST, FIRST OF EMP-NAME, and FIRST OF EMP-REC are elliptical references to the employee’s first name (not popularly supported due to compiler complexity)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Implementation of Record Type<ul>
<li>Record Descriptor<ul>
<li>for each Field i: Name, Type, Offset<ul>
<li>Offset address relative to the beginning of the records is associated with each field</li>
</ul>
</li>
</ul>
<ul>
<li>Address</li>
</ul>
</li>
</ul>
</li>
<li>Tuple Types<ul>
<li>a tuple is a data type that is similar to a <em>record</em>, except that the <em>elements are not named</em><ul>
<li>record/(tuple) associated with one entity while array associated values with different entities</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Tuple Type in Python<ul>
<li>Initialization <code>myTuple = (3, 5.8, &#39;apple&#39;)</code><ul>
<li>closely related to its python lists, but <em>immutable</em> </li>
</ul>
</li>
</ul>
<ul>
<li>Access <code>myTuple[0]</code></li>
<li>Concatenation<ul>
<li><code>yourTuple = (&#39;banana&#39;, &#39;orange&#39;)</code>; </li>
<li><code>ourTuple = myTuple + yourTuple; # (3, 5.8, &#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Tuple Type in ML (typed-based functional language)<ul>
<li>Initialization<ul>
<li><code>val myTuple = (3, 5.8, &#39;apple&#39;);</code> ML tuples are also immutable</li>
</ul>
</li>
</ul>
<ul>
<li>Access <ul>
<li><code>#1(myTuple)</code> ML uses 1-based indexing</li>
</ul>
</li>
</ul>
<ul>
<li>define new tuple type<ul>
<li><code>type intReal = int * real;</code></li>
</ul>
</li>
</ul>
</li>
<li>Tuple Type in F#<ul>
<li>Initialization<ul>
<li><code>let tup = (3, 5, 7)</code> F# tuples are <em>immutable</em></li>
</ul>
</li>
</ul>
<ul>
<li>assignments<ul>
<li><code>let a, b, c = tup</code> This assigns a tuple to a tuple pattern 3 to a, 5 to b, and 7 to c</li>
<li>Tuples can be used in Python, ML, and F# to allow functions to return multiple values</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Review: List Type in Lisp<ul>
<li>The primary structure of Lisp and Scheme</li>
<li>Lists are delimited by parentheses and use no commas<ul>
<li>(A B C D) and (A (B C) D)</li>
</ul>
</li>
<li>Data and code have the same form<ul>
<li>As data, (A B C) is literally what it is</li>
<li>As code, (A B C) is the function A applied to the parameters B and C</li>
</ul>
</li>
<li>The interpreter needs to know which a list is, so if it is data, we quote it with an apostrophe<ul>
<li>‘(A B C) is data</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>List Type in Python<ul>
<li>The list data type also serves as Python’s <em>arrays</em></li>
<li>Unlike Scheme, ML, and F#, Python’s lists are <em>mutable</em></li>
<li>Elements can be of any type</li>
<li>Create a list with an assignment <code>myList = [3, 5.8, &quot;grape&quot;]</code></li>
<li>list comprehensions<ul>
<li>Derived from set notation</li>
<li><code>[x * x for x in range(7) if x % 3 == 0]</code></li>
<li>Note: range(7) creates [0, 1, 2, 3, 4, 5, 6] Constructed list: [0, 9, 36]</li>
</ul>
</li>
</ul>
</li>
<li>Union Type<ul>
<li>A type whose variables are allowed to store different type values at different times during execution</li>
</ul>
</li>
</ul>
<ul>
<li>Free vs. Discriminated Unions<ul>
<li> Fortran, C, and C++ provide union constructs in which there is no language support for type checking; the union in these languages is called <em>free union</em></li>
<li>Allows you to avoid type checking and create unsafe code<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free union in C</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> intEl;</span><br><span class="line">    <span class="keyword">float</span> floatEl;</span><br><span class="line">&#125; el1;</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line">el1.intEl = <span class="number">27</span>; <span class="comment">// 00000000000000000000000000011011 </span></span><br><span class="line">x = el1.floatEl; <span class="comment">// 00000000000000000000000000011011</span></span><br><span class="line"><span class="comment">// now x is the floating point bits representation of int value of 27</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Type checking of unions require that each union include a type indicator called a <em>discriminant</em></li>
<li>ML, Haskell, and F#<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; discriminant union in F#</span><br><span class="line">type Shape &#x3D;</span><br><span class="line">    | Rectangle of width : float * height : float </span><br><span class="line">    | Circle of radius : float</span><br><span class="line">let area myShape &#x3D;</span><br><span class="line">    match myShape with</span><br><span class="line">    | Rectangle (w, h) -&gt; w * h</span><br><span class="line">    | Circle (r) -&gt; pi * r * r</span><br><span class="line">let radius &#x3D; 15.0</span><br><span class="line">let myCircle &#x3D; Circle(radius)</span><br><span class="line">printfn &quot;Area of circle withradius %f: %f&quot; radius (area myCircle)</span><br><span class="line"></span><br><span class="line">let width, height &#x3D; 5.0, 10.0</span><br><span class="line">let myRectangle &#x3D; Rectangle(width, height)</span><br><span class="line">printf &quot;Area of rectangle with width %f and height %f &quot; width height printfn &quot;is %f&quot; (area myRectangle)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>Evaluation of Unions<ul>
<li>(unions don’t use that much memory)</li>
<li>Free unions are unsafe<ul>
<li>Do not allow type checking</li>
<li>Reason why Fortran, C, and C++ are not strongly typed</li>
</ul>
</li>
<li>Java and C# do not support unions<ul>
<li>Reflective of growing concerns for safety in programming language</li>
<li>How do these languages support the desire of having a variable represent different things at runtime?<ul>
<li>(Polymorphism)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h3><ul>
<li><p>Section 2.13 and 16.1-16.6</p>
</li>
<li><p>install <a target="_blank" rel="noopener" href="http://www.swi-prolog.org/">SWI-Prolog</a></p>
</li>
<li><p>Intro</p>
<ul>
<li>Programs in logic languages are expressed in a form of <em>symbolic logic</em></li>
<li>Use a <em>logical inferencing</em> process to produce results</li>
<li><em>Declarative</em> rather than Procedural<ul>
<li>Only specification of results are stated (not detailed procedures for producing them)</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbolic Logic</p>
<ul>
<li>Logic which can be used for the basic needs of formal logic:<ul>
<li><em>Express</em> propositions</li>
<li>Express <em>relationships</em> between propositions</li>
<li>Describe how <em>new</em> propositions can be <em>inferred</em> from other propositions</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Predicate Calculus</strong><ul>
<li>Particular form of symbolic logics used for logic programing</li>
<li>Functional languages based on <em>lambda calculus</em></li>
</ul>
</li>
</ul>
<ul>
<li>example propositions<ul>
<li><code>man(jake)</code> <code>likes(bill, steak)</code> <code>enrolled(you, cs3270)</code></li>
</ul>
</li>
</ul>
<ul>
<li>These are interesting, because <em>we attach meaning to them,</em> but <em>within the logical system</em> they are <em>simply structural building blocks</em>, with <em>no meaning</em> beyond that provided by explicitly-stated interrelationships</li>
</ul>
</li>
<li><p>Compound Propositions</p>
<ul>
<li>Operators<ul>
<li>Used to connect two or more atomic propositions<ul>
<li><code>Conjunction</code>, <code>disjunction</code>, <code>negation</code>, <code>implication</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Quantifiers<ul>
<li>Used to include variables in propositions<ul>
<li>Universal Quantifiers<ul>
<li>For every X woman(X) implies human(X)</li>
</ul>
</li>
<li>Existential quantifiers<ul>
<li>There exists X (mother(marry, X)) and/conjunction male(X)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog (Programmation en Logique)<ul>
<li>Developed by Alain Colmerauer and Philippe Roussel at the University of Aix-Marseille</li>
<li>First appeared in 1972</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog Preview - Facts<ul>
<li>Provide facts (or axioms)</li>
<li>The <em>knowledge base</em></li>
<li>For example: “It rains.”, “Fido barks.”, “Fido is outside.”</li>
</ul>
</li>
<li>Prolog Preview - Rules<ul>
<li>Provide inferencing rules (or theorems)</li>
<li>If <em>condition</em>, then also <em>conclusion</em></li>
<li>For example: If “it rains”, then “anything outside becomes wet”.</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog Review - Goals<ul>
<li>Query the Prolog system (hypothesis)</li>
<li>A <em>goal statement</em></li>
<li>For example: “Does Fido smell?”</li>
</ul>
</li>
<li>Helpful Restrictions<ul>
<li>Computer-friendly<ul>
<li>Most propositions can be written <em>many ways</em></li>
<li>That’s great for people, but a <em>nuisance</em> for computers</li>
<li>It turns out that if you make certain restrictions on the format of statements you can prove theorems <em>mechanically</em></li>
<li>That’s what <em>logic programming systems</em> do</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Clausal Form<ul>
<li>A standard form for propositions is desirable</li>
<li>One simple form is called <em>clausal form</em>:<ul>
<li>B1 or B2 … or m &lt;- implies - A1 and A2 and … An</li>
<li>if all the A’s are true, then at least one. is true</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Horn Clauses</strong><ul>
<li>We further restrict the form by insisting that all statements are in the form of <em>Horn clauses</em> consisting of a <em>head</em> (or LHS) and a <em>body</em> (or RHS)<ul>
<li>likes(bob, trout) &lt;- implies - likes(bob, fish) and fish(trout)</li>
<li>The head is a <em>single atomic proposition</em> (or <em>term</em> in Prolog)</li>
<li>The body is a list of <em>terms</em></li>
<li>A term can be a <em>constant</em>, <em>variable</em>, or <em>structure</em></li>
<li>The meaning of the statement is that the <em>conjunction</em> of the terms in the body <em>implies</em> the head</li>
<li>That is, the head is true if the all the conditions in the body is true</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Key components<ul>
<li>FACT - a clause with no body</li>
<li>RULE - a clause with both sides</li>
<li>GOAL/QUERY - a clause with no head</li>
</ul>
</li>
</ul>
<ul>
<li>Terms<ul>
<li>constant<ul>
<li>atom - sequence of characters, quoted character string<ul>
<li>lower case <code>cat</code> <code>dog</code>… <code>&#39;cat&#39;</code></li>
</ul>
</li>
</ul>
<ul>
<li>Number - Integer or Real <ul>
<li>no fraction like Racket</li>
</ul>
</li>
</ul>
</li>
<li><strong>variable</strong> (upper-case) <code>X</code> <code>Y</code> <code>Cat</code> <code>Dog</code> etc.<ul>
<li>comparison with atoms <code>cat</code> <code>&#39;cat&#39;</code>, <code>&#39;DOG&#39;</code></li>
<li>But an atom is not a variable; it is not bound to anything, never equal to anything else, it just symbolize something</li>
</ul>
</li>
</ul>
<ul>
<li>structure<ul>
<li>consists of a <em>functor</em> and a parenthesized list of arguments</li>
<li><em>functor(term_1, term_2, …, term_n)</em> </li>
</ul>
<ul>
<li>e.g. <code>has_capital(france, &#39;paris&#39;)</code>, <code>tall(jim)</code></li>
</ul>
<ul>
<li>The definition is <em>recursive</em>, b.c. a term can be <em>constant</em>, <em>variable</em> or *another structure</li>
</ul>
</li>
</ul>
</li>
<li>Prolog<ul>
<li>declarative and imperative<ul>
<li>prolog can be thought of <em>declaratively</em> or <em>imperatively</em> (built on imperative computer)</li>
<li>we’ll emphasize the declarative semantics for now, because that’s what makes logic programming interesting</li>
<li>we’ll get into the imperative semantics later</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog Process<ul>
<li>Prolog allows you to state a bunch of <em>facts</em> and <em>rules</em> that the Prolog interpreter collects in its <em>DATABASE</em></li>
<li>Then you pose a <em>query</em> (<em>goal</em>) and Prolog attempts to find inference steps (and assignments of values to variables) that allow it to prove your query starting from the <em>facts</em> (or <em>axioms</em>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog - <strong>Facts</strong><ul>
<li>The <em>knowledge base</em>, sometimes referred to as the “world” or “universe”</li>
<li>Inference rules allow to create new facts from known facts, but need some facts to start with</li>
<li>Horn clause with no body</li>
<li><code>mother(mary, fred)</code><ul>
<li>you can either think of this as an predicate asserting that mary is the mother of fred – or a data structure (tree) in which the functor (atom) mother is the root, mary is the left child, and fred is the right child</li>
</ul>
</li>
<li>example on the slide <code>parent(sam, pat).</code><ul>
<li>a prolog program of <em>six</em> facts</li>
<li>defining a predicate <code>parent</code> of <em>arity</em> two (sometimes written as <em>parent/2</em>) (we now also might called these function predicate)</li>
<li>we would naturally interpret these facts about families</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog - rules<ul>
<li>describe known implications / relations</li>
<li>Rules are theorems that allow the interpreter to infer things</li>
<li>horn clauses with both a head and a body</li>
<li>To be interesting,rules generally contain <em>variables</em><ul>
<li>If “X barks”, then “X is a dog”</li>
<li>Horn clause: dog(X) &lt;-implies- barks(X)</li>
<li>Prolog syntax: <code>dog(X) :- barks(X).</code></li>
</ul>
</li>
</ul>
<ul>
<li>employed(X) :- employs(Y, X).<ul>
<li>Can be read: <em>for all X, X is employed if there exists a Y such that Y employs X</em></li>
<li>The example does <em>not</em> say that X is employed <em>only if</em> there is a Y that employs X</li>
<li>Alternative definitions<ul>
<li>dog(X) :- barks(X).</li>
<li>dog(X) :- wags_tail(X).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SWI Prolog<ul>
<li>Prompting for a query with ?-</li>
<li>Normally interactive: get query, print result, repeat</li>
</ul>
</li>
</ul>
<ul>
<li>The <strong>consult</strong> Predicate<ul>
<li>consult<ul>
<li>a predefined predicate to read a program from a file into a database</li>
<li>also a menu option under File</li>
</ul>
</li>
<li>DATABASE.PL with facts and rules</li>
<li>e.g. <code>consult(&#39;C:\\cs3270\\prolog\\database.pl&#39;). </code></li>
</ul>
</li>
</ul>
<ul>
<li>Prolog - Goals<ul>
<li>Query / reasoning about the “world”</li>
<li>Prolog attempts to satisfy the goal</li>
<li>e.g. with fact <code>barks(fido).</code> in the prompt <code>bars(X).</code> gives <code>X = fido.</code></li>
</ul>
</li>
</ul>
<ul>
<li>Unification<ul>
<li>The query you asked is the interpreter’s original <em>goal</em></li>
<li>In an attempt to <em>satisfy</em> that goal, it looks for facts or rules with which the goal can be <em>unified</em><ul>
<li>Unification is a process by which compatible statements are <em>merged</em></li>
</ul>
</li>
<li>A trivial unification is where a goal can be unified with “itself” <ul>
<li>e.g. <code>woman(jane) = woman(jane)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Unification and Instantiation<ul>
<li>A variable that does not have a value yet</li>
<li>… but which corresponds to a constant or value in another clause </li>
<li>… gets <em>instantiated</em> with that value</li>
<li>For example, the goal <code>studies(charlie, X)</code> is <em>unified</em> with the fact <code>studies(charlie, cs3270)</code> and the variable X is <em>instantiated</em> to cs3270</li>
</ul>
</li>
</ul>
<ul>
<li><p>Resolution Principle </p>
<ul>
<li>In 1965, Alan Robinson formalized a notion called “Resolution Principle” on how implications can be combined to <em>obtain new implications</em></li>
<li>Program Database<ul>
<li><code>clause1(fred).</code> <code>clause2(R) := clause1(R).</code> <code>clause3(X) := clause1(X).</code></li>
<li>if clause1 implies clause2, and clause2 implies clause3, then clause1 also implies clause3.</li>
</ul>
</li>
</ul>
</li>
<li><p>Conjunction <code>,</code> Disjunction <code>;</code></p>
<ul>
<li>unit clause - facts <code>women(jean).</code> <code>wealth(jean).</code></li>
<li>non-unit clause <code>happy(Person) :- woman(Person), wealthy(Person)</code><ul>
<li>has a <em>head</em> (LHS) and a <em>body</em> (RHS) rules</li>
<li>Person is a <em>variable</em>, jean is constant(atom)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Variable Scope<ul>
<li>the scope of a variable is the clause in which it appears<ul>
<li>If appears first on LHS have implicit universal quantifiers (<em>for-all</em>)</li>
<li>if appears first on RHS have implicit existential quantifiers (<em>there-exist</em>)</li>
<li>example: <code>grandmother(A, C) :- mother(A, B), mother(B, C).</code><ul>
<li>for all A, C [A is the mother of C if there exists a B such that A is the mother of B and B is the mother of C]</li>
</ul>
</li>
</ul>
<ul>
<li>probably want another rule (like or):  grandmother(A, C) :- mother(A, B), father(B, C).</li>
</ul>
</li>
</ul>
</li>
<li>Example <ul>
<li>database consists of edges fact and <ul>
<li>path(<strong>X</strong>, <strong>X</strong>). % all nodes have path to itself</li>
<li>path(<strong>X</strong>, Y) :- edge(<strong>X</strong>, Z), path(Z, Y)</li>
</ul>
</li>
<li>some queries<ul>
<li>path(c, c).</li>
<li>path(X, c).</li>
<li>Note: the variable X in the program database and the var X in the query are different (different scope)</li>
<li>Note: <ul>
<li>can type <code>trace.</code> in the ide and will gives steps </li>
<li>Prolog tries through <em>order of the database</em></li>
<li>type space to search next one, type enter to end</li>
</ul>
</li>
<li>Prolog will exhaust every options</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>How Prolog Works<ul>
<li>The interpreter <em>starts at the beginning</em> of your database and looks for something with which to answer the current goal<ul>
<li>if it finds a fact, great! It succeeds</li>
<li>if it finds a rule, it attempts to satisfy the terms (sub-goals), in the body of the rule (the rhs) <em>left-to-right</em>, and <em>depth first</em></li>
<li>This <em>ordering</em> is part of Prolog, <strong>not</strong> of logic programing in general</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Prolog Goals</p>
<ul>
<li><p>When it attempts resolution, the Prolog interpreter pushed the <em>current goal</em> onto a stack, makes the <em>first term</em> (or <em>subgoal</em>) in the body of the current goal, and goes back to the beginning of the database and starts looking again</p>
</li>
<li><p>if it gets through the first term/goal of a body successfully, the interpreter continues with the <em>next one</em> </p>
</li>
<li><p>if it gets the way through the body, the goal is satisfied and it backs up a level and proceeds.</p>
</li>
<li><p>if it fails to satisfy the terms in the body of a rule, the interpreter undoes the unification of the left hand side (this includes uninstantiating any variables that were given values as a result of the unification)</p>
</li>
</ul>
<ul>
<li><p>it keeps looking through the database for something else with which to unify (this process is called <em>backtracking</em>)</p>
</li>
<li><p>if the interpreter gets to the end of database without succeeding, it backs out a level (that’s how it might fail to satisfy something in a body) and continues from there</p>
</li>
</ul>
</li>
<li><p>Prolog Tree</p>
<ul>
<li><p>we  can visualize a backtracking search as a tree in which the top-level goal is the root and the leaves are facts</p>
</li>
<li><p>the children of the root are all the rules and facts with which the goal can unify</p>
</li>
<li><p>The interpreter does an ‘OR’ across them: if any one of them succeeds then the goal succeeds</p>
</li>
<li><p>The children of a node in the second level of the tree are the terms in the body of the rule</p>
</li>
<li><p>The interpreter does an ‘AND’ across these: all of them must succeed in order for parent to succeed</p>
</li>
<li><p>The overall search tree then consists of alternating ‘AND’ and ‘OR’ levels</p>
<ul>
<li>note that in trace output X is a number (which is instantiated by the search process) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="More-Prolog-Oct-21-23"><a href="#More-Prolog-Oct-21-23" class="headerlink" title="More Prolog (Oct 21 23)"></a>More Prolog (Oct 21 23)</h3><ul>
<li><p>Order matters in Prolog</p>
<ul>
<li>Prolog is <strong>not</strong> purely declarative<ul>
<li>the ordering of the database and the left-to-right pursuit of sub-goals gives a <em>deterministic imperative semantics</em> to searching and backtracking</li>
</ul>
</li>
</ul>
<ul>
<li>Changing the order of statements in the database give you different results<ul>
<li>it can lead to infinite loops</li>
<li>it can certainly result in inefficiency</li>
</ul>
</li>
</ul>
</li>
<li><p>Order matters</p>
<ul>
<li>consider these definitions<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path(X, Y) :- path(X,Z), edge(Z,Y).</span><br><span class="line">path(X, X).</span><br></pre></td></tr></table></figure>
<ul>
<li>query path(a, a) will result in indefinite loop </li>
</ul>
</li>
<li>fix the infinite recursion of the previous database by making the rules <strong>right recursive</strong> rather than left recursive</li>
<li>often good to put base case first, too<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path(X, X).</span><br><span class="line">path(X, Y) :- edge(X, Z), path(Z, Y).</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>command <code>make</code> update database = reconsult, use <code>a</code> to quit error and return to the prompt</li>
</ul>
</li>
<li><p>Two more examples</p>
<ul>
<li>underscore: don’t care variables</li>
<li><em>substring</em>: Predicate sub_string<ul>
<li>sub_string(+String, ?Before, ?Length, ?After, ?Substring)</li>
<li>pres(First, Last, _, _, _), sub_string(First, _, _, _’James’).<ul>
<li>what if we don’t want First being printed out? -.-</li>
<li>create a rule inside the data base </li>
<li>contains(Match, Last) :- pres(First, Last, _, _, _), sub_string(First, _, _, Match). % use match to match and only print last name </li>
<li>contains(‘James’, Who)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>use _ to resolve singleton warning</p>
<ul>
<li><p>writer(X) := author(X, _).</p>
</li>
<li><p>multi_writter :- author(Author, X), author(Author, Y), X == Y.</p>
<ul>
<li>== only works for num, but == works for symbol and number</li>
</ul>
</li>
<li><p>Predicate setof/3</p>
<ul>
<li>use of query setof(X, multi_writer(X), L).</li>
<li>L is the var of set</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Prolog and Lists</p>
<ul>
<li>List syntax: lists are enclosed in square brackets with elements separated by commas <ul>
<li><code>[a, b, c, d]</code></li>
<li><code>[] % empty list</code></li>
</ul>
</li>
</ul>
<ul>
<li>“CAR” and “CDR”<ul>
<li>use the bar operator “|” to separate the head of the list from the rest of the list</li>
<li><strong>‘=’ means unification</strong></li>
<li>[HEAD|TAIL] = [1, 2, 3, 4].</li>
<li>rule() :- [HEAD|TAIL] = [1, 2, 3, 4, 5], process(Head), recursion(Tail).</li>
</ul>
</li>
</ul>
</li>
<li><p>List processing example</p>
<ul>
<li>member % <a target="_blank" rel="noopener" href="https://www.cpp.edu/~jrfisher/www/prolog_tutorial/2_7.html">a reference material</a><ul>
<li>The subgoal ‘member(X, [])’ on the lowest right branch will not match the head of any ‘member’ clause. In particular ‘[]’ will not unify with a pattern of the form ‘[X|R]’ because the latter represents a list with at least one element.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_member(Item, [Item|_]).</span><br><span class="line">my_member(Item, [_|Tail]) :- my_member(Item, Tail).</span><br><span class="line"></span><br><span class="line">my_member(a, [a, b, c, d]).</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Prolog and Lists</p>
<ul>
<li>Return values<ul>
<li>prolog predicate only returns <em>true/false</em>, depending upon whether the predicate can be satisfied or not</li>
<li>if we want to return a value from our Prolog rules, <em>an additional parameter</em> is required to carry the result back</li>
</ul>
</li>
</ul>
<ul>
<li>use variable to return result<ul>
<li>if you want to append two lists, the predicate append must have a third parameter that is the result of appending the first two params <code>append([a. b. c], [d, e, f], Lst)</code></li>
</ul>
</li>
</ul>
<ul>
<li>list constructions<ul>
<li>use the same synax for destructing a list (i.e. car/cdr) to construct a list<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_append([], Lst2, Lst2).</span><br><span class="line">my_append([Head|Tail], Lst2, [HEAD|Result]) :- my_append(Tail, Lst2, Result).</span><br><span class="line"></span><br><span class="line">% X &#x3D; [C|[]] gives X &#x3D; [C]</span><br><span class="line"></span><br><span class="line">my_append([a, b, c], X, [a, b, c, d, e, f]).</span><br><span class="line">my_append(X, Y, [a, b, c, d, e, f]).</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>remove</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my_remove(_, [], []).</span><br><span class="line">my_remove(Item, [Item|Tail], Tail). </span><br><span class="line"></span><br><span class="line">% my_remove(Item, [Item|Tail], Result) :- my_remove(Item, Tail, Result). will remove multiple items</span><br><span class="line"></span><br><span class="line">% if we don&#39;t have Item \&#x3D;&#x3D; Head below, my_remove(Item, [Item|Tail], Tail). :- !. once find this is true won&#39;t execute following</span><br><span class="line"></span><br><span class="line">my_remove(Item, [Head|Tail], [Head|Result]) :- Item \&#x3D;&#x3D; Head, my_remove(Item, Tail, Result).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_remove(Item, [Head|Tail], [Head|Result]) :- not(Item &#x3D; Head), my_remove(Item, Tail, Result).</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eg will fail when my_remove(X, [a, c, b], [a, b]) </span><br><span class="line">&#x2F;&#x2F; with the third rule, asking if X can be unified with a, of cause it can (it&#39;s not asking equality), then ‘not’ it make anything impossible</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not(Item &#x3D;&#x3D; Head) works</span><br></pre></td></tr></table></figure>
<ul>
<li><code>=</code> is <strong><a target="_blank" rel="noopener" href="http://www.dai.ed.ac.uk/groups/ssp/bookpages/quickprolog/node12.html">unification</a></strong>, it succeeds when the two terms are unified. whereas == is equality</li>
</ul>
</li>
<li><p>filter (filter odd number)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filter([], []).</span><br><span class="line">% result val comes form right hand rule</span><br><span class="line">filter([Head|Tail], [Head|Result]) :- (Head mod 2) &#x3D;:&#x3D; 0, filter(Tail, Result).</span><br><span class="line"></span><br><span class="line">% &#x3D;:&#x3D; numeric equality, &#x3D;&#x3D; atomic equality</span><br><span class="line">% bc we have mod operation: mod(Head, 2)</span><br><span class="line">% inequality of number &#x3D;\&#x3D;</span><br><span class="line"></span><br><span class="line">filter([Head|Tail], Result) :- (Head mod 2) &#x3D;:&#x3D; 1, filter(Tail, Result).</span><br><span class="line"></span><br><span class="line">filter([1, 2, 3, 4], Lst)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Write a predicate that can <em>only be unified</em> with a list that contains <em>one element</em>?</p>
<ul>
<li>write_one([H]) :- write(H).</li>
<li>write_one([H|[]]) :- write(H).</li>
</ul>
</li>
<li><p>The = predicate</p>
<ul>
<li>The goal = (X, Y) succeeds if and only if X and Y can be unified</li>
<li><code>=(parent(z), parent(X)</code><ul>
<li>gives X = z</li>
</ul>
</li>
</ul>
<ul>
<li>since = is an operator, it can be and usually is written like this<ul>
<li><code>parent(z) = parent(X)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Arithmetic operators</p>
<ul>
<li>predicate +, -, * / are operators too, with the use precedence and associativity</li>
<li>prolog lets you use operator notation, and prints it out that way, but the underlying term is still +(1, *(2, 3))<ul>
<li>X = +(1, *(2, 3)). X = 1 + 2 * 3.</li>
</ul>
</li>
</ul>
<ul>
<li>not evaluated!<ul>
<li>in the examples below, the term is still +(1, *(2, 3))</li>
</ul>
<ul>
<li><code>7 = 1 * 2 + 3</code> gives false</li>
<li>+(X, Y) = 1 + 2 * 3. gives X = 1, Y = 2 * 3.</li>
</ul>
</li>
</ul>
</li>
<li><p>The <strong>is</strong> Operator</p>
<ul>
<li>to evaluate an arithmetic expression, use the “is” operator</li>
<li><code>X is 5*3.</code></li>
<li>% only evaluates the rhs</li>
<li><code>6 + 2 is 9 - 1.</code> gives false</li>
<li>rhs of ‘is’ must already be instantiated<ul>
<li><code>X is Y</code> gives error</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Comparison operators<ul>
<li>&lt;, &gt;, =&lt; (not &lt;=), &gt;=, =:= (<strong>both sides are evaluated</strong>), ==</li>
</ul>
</li>
</ul>
<ul>
<li>[H1, H2|T] will gives the first two elements of the list<ul>
<li>[H1 | [H2 | T]] does the same thing</li>
</ul>
</li>
</ul>
<ul>
<li>Prolog and number processing<ul>
<li>when processing/return numbers, it is sometimes beneficial to create auxiliary predicates that take an additional argument that is an accumulator</li>
<li>these functions can be written in a <em>tail-recursive</em> manner (implemented as an iterative loop by the system)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?- pred(INPUT, OUTPUT)</span><br><span class="line"></span><br><span class="line">predAcc(INPUT, ACC, ACC).</span><br><span class="line"></span><br><span class="line">predAcc(INPUT, OUTPUT, ACC) :- ACC2 FROM ACC, predAcc(INPUT, OUTPUT, ACC2).</span><br><span class="line"></span><br><span class="line">pred(INPUT, OUTPUT) :- predAcc(Input, OUTPUT, ACC INITIAL VALUE).</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Tail Recursion in Prolog<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_3_and_double(X, Result) :- Result is 2 * (X + 3). % assign numeric value</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fact(0, 1) :- !. % exit </span><br><span class="line">% have to get the value first and then assign the value</span><br><span class="line">fact(N, FN) :- N1 is N - 1, fact(N1, FN1), FN is N * FN1.</span><br><span class="line"></span><br><span class="line">fact(4, X).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fact_acc(0, Acc, Acc) :- !.</span><br><span class="line"></span><br><span class="line">fact_acc(N, FN, Acc) :- Acc2 is Acc * N, N1 is N - 1, fact_acc(N1, FN, Acc2).</span><br><span class="line"></span><br><span class="line">fact2(N, FN) :- fact_acc(N, FN, 1).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len([], 0).</span><br><span class="line">len([_|Tail], Result) :- len(Tail, Result2), Result is 1 + Result2.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len2([], Acc, Acc).</span><br><span class="line"></span><br><span class="line">len_acc([_|Tail], Result, Acc) :- Acc2 is Acc + 1, len_acc(Tail, Result, Acc2).</span><br><span class="line"></span><br><span class="line">len2(Lst, Result) :- len_acc(Lst, Result, 0).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max([Head], Head).</span><br><span class="line"></span><br><span class="line">max([Head|Tail], Head) :- max(Tail, Result2), Head &gt; Result2.</span><br><span class="line">max([Head|Tail], Result2) :- max(Tail, Result2), Head &#x3D;&lt; Result2.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="More-Prolog"><a href="#More-Prolog" class="headerlink" title="More Prolog"></a>More Prolog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% to make max don&#39;t call twice, we find Result 2 twice in the previous example</span><br><span class="line">% later we would learn about let expression</span><br><span class="line">% now let&#39;s use or</span><br><span class="line">max2([Head], Head).</span><br><span class="line">max2([Head|Tail], Result) :- </span><br><span class="line">    max2(Tail, Result2), </span><br><span class="line">    (</span><br><span class="line">        (Head &gt; Result2, Result &#x3D; Result2); </span><br><span class="line">        (Head &#x3D;&lt; Result2, Result &#x3D; Resukt2)</span><br><span class="line">    ).</span><br><span class="line"></span><br><span class="line">% tail recursive version</span><br><span class="line">max_acc([], Acc, Acc).</span><br><span class="line">max_acc([Head | Tail], Result, Acc) :- Head &gt; acc, max_acc(Tail, Result, Head).</span><br><span class="line">max_acc([Head | Tail], Result, Acc) :- Head &#x3D;&lt; acc, max_acc(Tail, Result, Acc).</span><br><span class="line"></span><br><span class="line">max3([Head|Tail], Result) :- max_acc(Tail, Result, Head).</span><br><span class="line"></span><br><span class="line">% can use time() predicate to query time</span><br></pre></td></tr></table></figure></li>
<li><strong>Quicksort</strong><ul>
<li>choose a pivot</li>
<li>less than or equals elements are left pivot</li>
<li>greater than elements are right of pivot</li>
<li>recursive call on two sides<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">partition([], <span class="symbol">_</span>, [], []).</span><br><span class="line"><span class="comment">% what we don&#x27;t know is L and H</span></span><br><span class="line">partition([<span class="symbol">Head</span>|<span class="symbol">Tail</span>], <span class="symbol">P</span>, [<span class="symbol">Head</span>|<span class="symbol">L</span>], <span class="symbol">H</span>) :- <span class="symbol">Head</span> =&lt; <span class="symbol">P</span>, partition(<span class="symbol">Tail</span>, <span class="symbol">P</span>, <span class="symbol">L</span> <span class="symbol">H</span>).</span><br><span class="line">partition([<span class="symbol">Head</span>|<span class="symbol">Tail</span>], <span class="symbol">P</span>, <span class="symbol">L</span>, [<span class="symbol">Head</span>|<span class="symbol">H</span>]) :- <span class="symbol">Head</span> &gt; <span class="symbol">P</span>, partition(<span class="symbol">Tail</span>, <span class="symbol">P</span>, <span class="symbol">L</span> <span class="symbol">H</span>).</span><br><span class="line"></span><br><span class="line">qsort([], []) :- !.</span><br><span class="line"></span><br><span class="line"><span class="comment">% L will be all elements that are lower, and H are the elements that are greater</span></span><br><span class="line">qsort([<span class="symbol">X</span>|<span class="symbol">Y</span>], <span class="symbol">SXY</span>) :- </span><br><span class="line">    partition(<span class="symbol">Y</span>, <span class="symbol">X</span>, <span class="symbol">L</span>, <span class="symbol">H</span>), qsort(<span class="symbol">L</span>, <span class="symbol">SL</span>), qsort(<span class="symbol">H</span>, <span class="symbol">SH</span>),</span><br><span class="line">    append(<span class="symbol">SL</span>, [<span class="symbol">X</span>], <span class="symbol">SLX</span>), append(<span class="symbol">SLX</span>, <span class="symbol">SH</span>, <span class="symbol">SXY</span>).</span><br><span class="line"></span><br><span class="line">partition([])</span><br><span class="line"></span><br><span class="line"><span class="comment">% append only accepts 3 parameters, and can&#x27;t do</span></span><br><span class="line">append(<span class="symbol">SL</span>, <span class="symbol">X</span>, <span class="symbol">SH</span>, <span class="symbol">SXY</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>logic problems<ul>
<li>eight queens<ul>
<li>could represent with a queen predicate: queen(2, 5)</li>
<li>but there are no other pieces: no king(X, Y)</li>
<li>We will use the form X/Y(not evaluated)</li>
<li>can force prolog to give use 8 elements array with a certain permutation<ul>
<li>X = [1/<em>, 2/</em>, 3/<em>, 4/</em>, 5/<em>, 6/</em>, 7/<em>, 8/</em>], legal(X).<ul>
<li>don’t need to check X if we use this to query<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nocheck(_, []).</span><br><span class="line">nocheck(X&#x2F;Y, [X1&#x2F;Y1 | Rest]) :- </span><br><span class="line">    X &#x3D;\&#x3D; X1, </span><br><span class="line">    Y &#x3D;\&#x3D; Y1,</span><br><span class="line">    abs(X - X1) &#x3D;\&#x3D; abs(Y - Y1),</span><br><span class="line">    nocheck(X&#x2F;Y, Rest).</span><br><span class="line"></span><br><span class="line">legal([]).</span><br><span class="line">legal([X&#x2F;Y | Rest]) :- </span><br><span class="line">    legal(Rest),</span><br><span class="line">    member(X, [1, 2, 3, 4, 5, 6, 7, 8]), % works as a loop with member predicate</span><br><span class="line">    member(Y, [1, 2, 3, 4, 5, 6, 7, 8]),</span><br><span class="line">    nocheck(X&#x2F;Y, Rest).</span><br><span class="line"></span><br><span class="line">legal([]).</span><br><span class="line">legal([X&#x2F;Y | Rest]) :- </span><br><span class="line">    legal(Rest),</span><br><span class="line">    % member(X, [1, 2, 3, 4, 5, 6, 7, 8]),</span><br><span class="line">    member(Y, [1, 2, 3, 4, 5, 6, 7, 8]),</span><br><span class="line">    % do 1 &#x3D;&lt; Y, Y &#x3D;&lt; 8, instead of member wouldn&#39;t work since Y need to be instantiated</span><br><span class="line">    nocheck(X&#x2F;Y, Rest).</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Tic-Tac-Toe<ul>
<li>This program finds the next move, given a current board configuration</li>
<li>it does not play a whole game</li>
<li>it depends on the ordering of rules<ul>
<li>move(A) is the root rule</li>
<li>A is a result param</li>
</ul>
</li>
<li>No winning strategy (each player can force a draw)</li>
</ul>
</li>
<li>Specify Lines of Three cells<ul>
<li>cells on the grid are numbered</li>
<li>facts (express that three given cells lie in a line):<ul>
<li><code>ordered_line(1, 5, 9).</code> etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Line of Three (Permuted) Cells<ul>
<li>Rules<ul>
<li><code>line(A, B, C) :- ordered_line(A, B, C).</code> etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Tic-Tac-Toe<ul>
<li>how to make a good move to a cell:<ul>
<li><code>move(A) :- good(A), empty(A).</code></li>
</ul>
</li>
</ul>
<ul>
<li>which cell is empty?<ul>
<li><code>empty(A) :- not(full(A)).</code></li>
</ul>
</li>
</ul>
<ul>
<li>Cell has an X or O placed in it?<ul>
<li><code>full(A):- x(A)</code>. <code>full(A) :- o(A).</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>A Good Move<ul>
<li>Strategy (key is ordering the following rules):<ul>
<li><code>good(A) :- win(A)</code>.<ul>
<li>a cell where we win</li>
</ul>
</li>
<li><code>good(A) :- block_win(A).</code><ul>
<li>a cell where we block the opponent from a win</li>
</ul>
</li>
<li><code>good(A) :- split(A).</code><ul>
<li>a cell where we can make a split to win</li>
</ul>
</li>
<li><code>good(A) :- block_split(A).</code></li>
<li><code>good(A) :- build(A).</code><ul>
<li>choose a cell to get a line</li>
</ul>
</li>
<li>good(5). good(1). good(3). … %7, 9, 2, 4, 6, 8</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>A good move (1) - win<ul>
<li>first choice is to win<ul>
<li><code>win(A) :- x(B), x(C), line(A, B, C).</code></li>
</ul>
</li>
</ul>
</li>
<li>A good move (2) - block_win<ul>
<li>block opponent from winning:<ul>
<li><code>block_win(A) :- o(B), o(C), line(A, B, C).</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>A good move (3) - split<ul>
<li>example x(5) x(7) o(3) o(4)<ul>
<li>If X takes cell 8 or 9, no future move by O will be able to stop X from winning the game, as X has two ways to win</li>
</ul>
</li>
<li>opponent cannot block us from wining next:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(A) :- x(B), x(C), different(B, C),</span><br><span class="line">            line(A, B, D), line(A, C, E),</span><br><span class="line">            empty(D), empty(E).</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>A Good Move (4) – block_split</p>
<ul>
<li>Prevent opponent from creating a split:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_split(A) :- o(B), o(C), different(B, C),</span><br><span class="line">                line(A, B, D), line(A, C, E),</span><br><span class="line">                empty(D), empty(E).</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>A Good Move (5) – build</p>
<ul>
<li>Pick a cell toward three in a row:<ul>
<li><code>build(A) :- x(B), line(A, B, C), empty(C).</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Addition from Previous Students</p>
<ul>
<li>If we attempt to block a split, we should do so such that it helps us</li>
<li>Added the following rule:<ul>
<li><code>good(A) :- block_split(A), build(A).</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Foxes and Hens Puzzle</p>
<ul>
<li>3 fox and 3 hens want to cross the river</li>
<li>If in the process of crossing the river we ever end up with more foxes than hens on either shore, the foxes are likely to eat the hens.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">%% Foxes and hens</span><br><span class="line"></span><br><span class="line">% configuration: [left foxes, left hens, left boats]</span><br><span class="line">% 0 &lt;&#x3D; LF, LH &lt;&#x3D; 3; 0 &lt;&#x3D; LB &lt;&#x3D; 1</span><br><span class="line"></span><br><span class="line">% NB: use &quot;not&quot; instead of &quot;\+&quot; for Edinburgh, rather than ISO, Prolog</span><br><span class="line"></span><br><span class="line">initial([3, 3, 1]).     % the initial configuration</span><br><span class="line">final([0, 0, 0]).       % the final configuration</span><br><span class="line"></span><br><span class="line">solve(L) :-</span><br><span class="line">    initial(Start),</span><br><span class="line">    final(Finish),</span><br><span class="line">    path(Start, Finish, [Start], P),</span><br><span class="line">    reverse(P, L).              % print in &quot;natural&quot; order</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path(A, A, V, V).</span><br><span class="line"></span><br><span class="line">path(A, Z, V, P) :-</span><br><span class="line">    % states in V are verboten</span><br><span class="line">    successor(B, A),            % reach B from A in one move</span><br><span class="line">    not(member(B, V)),           % haven&#39;t been in B before</span><br><span class="line">    path(B, Z, [B | V], P).</span><br><span class="line"></span><br><span class="line">successor([LF2, LH2, 1], [LF1, LH1, 0]) :-  % move right to left</span><br><span class="line">    % assume from state is feasible and safe</span><br><span class="line">    member([MF,MH], [[0,1], [1,1], [1,0], [2,0], [0,2]]),</span><br><span class="line">    % MF is number of moved foxes, MH is number of moved hens</span><br><span class="line">    LF2 is (LF1 + MF),</span><br><span class="line">    LH2 is (LH1 + MH),</span><br><span class="line">    LF2 &#x3D;&lt; 3,</span><br><span class="line">    LH2 &#x3D;&lt; 3,</span><br><span class="line">    RF2 is (3 - LF2),</span><br><span class="line">    RH2 is (3 - LH2),</span><br><span class="line">    safe(LH2, LF2), safe(RH2, RF2).</span><br><span class="line"></span><br><span class="line">successor([LF2, LH2, 0], [LF1, LH1, 1]) :-  % move left to right</span><br><span class="line">    % assume from state is feasible</span><br><span class="line">    member([MF,MH], [[0,2], [0,1], [1,1], [1,0], [2,0]]),</span><br><span class="line">    LF2 is (LF1 - MF),</span><br><span class="line">    LH2 is (LH1 - MH),</span><br><span class="line">    LF2 &gt;&#x3D; 0,</span><br><span class="line">    LH2 &gt;&#x3D; 0,</span><br><span class="line">    RF2 is (3 - LF2),</span><br><span class="line">    RH2 is (3 - LH2),</span><br><span class="line">    safe(LH2, LF2), safe(RH2, RF2).</span><br><span class="line"></span><br><span class="line">safe(H, F) :- H &gt;&#x3D; F, !.</span><br><span class="line">safe(H, F) :- H &#x3D;:&#x3D; 0, !.</span><br><span class="line">    % proving same config safe two different ways only leads to</span><br><span class="line">    % spurious paths; hence the cut.</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Back-to-Chapter-6-Pointer-and-Reference-Types"><a href="#Back-to-Chapter-6-Pointer-and-Reference-Types" class="headerlink" title="Back to Chapter 6: Pointer and Reference Types"></a>Back to Chapter 6: Pointer and Reference Types</h3><ul>
<li>section 6.11</li>
<li>Pointer Types<ul>
<li>A pointer type variable has a range of values that consists of memory addresses and a special value <strong>null</strong></li>
<li>indirect addressing<ul>
<li>provide the power of indirect addressing (e.g. using a pointer to step thru an array)</li>
</ul>
</li>
<li>Dynamic memory<ul>
<li>can be used to access a location in area where storage is dynamically created (usually called a <em>heap</em>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Pointer Operations<ul>
<li>Two fundamental operations: <em>assignment</em> and <em>dereferencing</em></li>
</ul>
<ul>
<li>assignment<ul>
<li>set a pointer variable’s value to some useful address</li>
</ul>
</li>
<li>dereferencing <ul>
<li>get the value stored at the location represented by the pointer’s value<ul>
<li>can be explicit or implicit</li>
<li><code>j = *ptr;</code></li>
<li>Sets j to value located via address ptr using the explicit * operator</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Problems with Pointers<ul>
<li><strong>Dangling Pointers</strong><ul>
<li>A pointer points to a heap-dynamic variable that has been deallocated (<em>dangerous</em>)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Memory Leak</strong><ul>
<li>Lost heap-dynamic variable</li>
<li>An allocated heap-dynamic variable that is no longer accessible to the user program (often called <em>garbage</em>)</li>
</ul>
</li>
</ul>
</li>
<li>Buffer Overflow and Secure Computing<ul>
<li>Pointers and array types unified in C<ul>
<li>can usually be used interchangeably</li>
<li>array subscripting is a synonym for equivalent pointer operations</li>
<li>one of the strengths of the C</li>
</ul>
</li>
</ul>
<ul>
<li>No Bounds Checking <ul>
<li>At the same time, a source of reliability and security problems in software</li>
<li>Pointers and array indices are not bounds checked in C (and related C++)</li>
<li><em>Between 2010 and 2015, buffer overflows accounted for between 10-16% of publicly reported security vulnerabilities in the U.S. National Vulnerability Database each year</em></li>
</ul>
</li>
</ul>
</li>
<li>Reference Types<ul>
<li>C++ includes a special kind of pointer type called a <strong>reference type</strong> that is used primarily for formal parameters<ul>
<li>Advantages of both pass-by-pointer and pass-by-value</li>
</ul>
</li>
</ul>
<ul>
<li>Java extends C++’s reference variables that replaces pointers entirely</li>
<li>C# includes both the references of Java and the pointers of C++ (though use of pointers is discouraged – must indicate methods as <strong>unsafe</strong>)</li>
</ul>
</li>
<li>Evaluation of Pointers<ul>
<li>Dangling pointers are problems as is heap management</li>
<li>Pointers are like <strong>goto</strong> – they widen the range of cells that can be accessed<ul>
<li>Extremely powerful and dangerous</li>
</ul>
</li>
<li>Pointers or references are necessary for dynamic data structures – so we can’t design a language without them</li>
</ul>
</li>
<li>A Solution to the Dangling Pointer Problem<ul>
<li><strong><em>Tombstone</em></strong><ul>
<li>Extra heap cell as a pointer to the heap-dynamic variable</li>
<li>The actual pointer variable points only at <em>tombstones</em></li>
</ul>
<ul>
<li>When heap-dynamic variable de-allocated, <em>tombstone remains</em>, but set to <em>nil</em></li>
<li>Costly in time and space</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Locks-and-keys</strong><ul>
<li>pointer values are represented as (key, address) pairs<ul>
<li>heap-dynamic variables are represented as variable plus cell for <em>integer lock value</em></li>
<li>when heap-dynamic variable allocated, lock value is created and placed in lock cell and key cell of pointer</li>
</ul>
</li>
</ul>
<ul>
<li>each dereference must <em>compare the key and the lock</em></li>
</ul>
</li>
<li>Explicit deallocation not allowed (like Java, run time garbage collection)<ul>
<li>Rust: memory safety without garbage collection (compiler will do that for us)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Heap Management / Garbage collection  <ul>
<li>a very complex <strong>run-time</strong> process</li>
<li>single-size cells vs. variable-size cells</li>
<li>two types of approaches below<ul>
<li>Reference Counters<ul>
<li>eager approach</li>
<li>reclamation is gradual (i.e. continual)</li>
</ul>
</li>
</ul>
<ul>
<li>Mark-sweep and stop-ns-copy<ul>
<li>lazy approaches </li>
<li>reclamation occurs when the list of variable space becomes empty (or low)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Reference counter</strong><ul>
<li>Maintain a counter in every cell which stores the number of pointers currently pointing at the cell</li>
<li>Reclaim cells when their count drops to zero</li>
<li>Root Space (start point of all references) -&gt; Head Space (keeps track of number pointers point at the cell)</li>
<li>Good<ul>
<li>It is intrinsically incremental, so significant delays in the application execution are avoided</li>
</ul>
</li>
</ul>
<ul>
<li>Bad<ul>
<li>Space required, execution time required, complications for cells connected circularly</li>
</ul>
<ul>
<li>can’t reclaim circular pointers</li>
</ul>
</li>
</ul>
</li>
<li><strong>Mark-and-Sweep</strong><ul>
<li>Recursively follow all “live” pointers, marking all discovered structures as useful</li>
<li>Then sweep over the entire heap and reclaim any structures not marked as useful</li>
<li>Also, turn off marks in preparation for next time</li>
</ul>
</li>
<li><strong>Stop-and-copy</strong><ul>
<li>Splits heap memory in half, all new allocations go into the active half</li>
<li>At collection time, recursively follow all “live” pointers and copy all discovered structures to other half, which becomes the active half</li>
<li>The inactive half now only contains garbage and is reclaimed “en masse”</li>
</ul>
</li>
<li>Generational Copiers<ul>
<li>Generational copiers exploit fact that many objects have short lives while others have long lives</li>
<li>Keep track of lifetimes (how many collection passes they have survived) and collect long lifetime objects <em>less frequently</em></li>
<li>eg Java<ul>
<li>young generation (eden + survivor space with two heaps), old generation (tenured), permanent generation (permanent)</li>
</ul>
</li>
</ul>
</li>
<li>Lazy Garbage Collection <strong>Comparison</strong><ul>
<li><em>Memory utilization</em>: <ul>
<li>Mark-and-Sweep: all of heap + fragmentation (the heap could be really fragmented b.c. the cell stays where they are)</li>
</ul>
<ul>
<li>Stop-and-copy: half of heap + compaction (every time copy we will do it in a nice order)</li>
</ul>
</li>
<li><em>running time</em>:<ul>
<li>Mark-and-Sweep: touch all live objects then <em>sweep</em> entire heap</li>
</ul>
<ul>
<li>Stop-and-copy: touch and <em>copy</em> all live object (faster b.c. only copy on half of the heap)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Eager and Lazy Garbage Collection Comparison<ul>
<li><em>Memory utilization</em>: <ul>
<li>Reference counter: space for count</li>
<li>Tracing: (=lazy Execution) No extra overhead (don’t need marks etc outside collection time)</li>
</ul>
</li>
<li><em>Runtime overhead</em><ul>
<li>Reference counter: Extra cost for certain operations</li>
<li>Tracing: (longer in collection time) stopping execution completely until all job is done</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Escape Analysis<ul>
<li>Determines if any references to a value <em>escape</em> the function where the value is declared</li>
<li>If no references escape, the value may be safely stored on the <em>stack</em></li>
<li>Values stored on the stack <em>do not need</em> to be allocated or freed<ul>
<li>Go, Java</li>
</ul>
</li>
<li>example <ul>
<li>car will be put on the <strong>stack</strong>, as we only need to return the string (Compiler will do this to help the performance of the program)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarDescription</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    String desc = car.genDesc(); </span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Continue-Chapter-6"><a href="#Continue-Chapter-6" class="headerlink" title="Continue Chapter 6"></a>Continue Chapter 6</h3><ul>
<li>Type Checking<ul>
<li>Activity of ensuring that the operands of an <em>operator</em> are of compatible types<ul>
<li>generalize the concept of operands and operators to include subprogram parameters and assignments</li>
</ul>
</li>
</ul>
<ul>
<li>if all type bindings are static, nearly all type checking can be static (at compile time)</li>
<li>if all type bindings are dynamic, type dynamic must be dynamic</li>
</ul>
</li>
</ul>
<ul>
<li>Compatible Type<ul>
<li>One that is either legal for the operator or is allowed under language rules to be implicitly converted, by compiler-generated code, to a legal type<ul>
<li>this automatic conversion is called a <em>coercion</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Type Error<ul>
<li>the application of an operator to an operand of an appropriate type</li>
</ul>
</li>
</ul>
<ul>
<li>Strong Typing<ul>
<li>strongly typed programming language<ul>
<li>if type errors are always detected whether at compile time or run run time</li>
</ul>
</li>
</ul>
<ul>
<li>advantage strong typing<ul>
<li>allows detect the misuses of variables that result in incorrect answers due to type errors</li>
</ul>
</li>
</ul>
<ul>
<li>examples<ul>
<li>no strongly typed at all: C, C++</li>
<li>Almost, Java C# - <em>Explicit Type Casting</em></li>
<li>Yes: F#, ML</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Strong Typing and Coercion<ul>
<li>Coercion<ul>
<li>coercion rules greatly affect string typing - they can weaken it considerably </li>
<li>can cause some programming errors to go undetected by the compiler</li>
</ul>
</li>
</ul>
<ul>
<li>example<ul>
<li>you meant to add two <code>int</code> variables <code>a</code> and <code>b</code>, but accidentally typed <code>a + d</code> where <code>d</code> is an double variable<ul>
<li>C++ and Java will perform a coercion</li>
<li>An Ada (and Rust) compiler would flag this as an error</li>
<li>Java would catch the error if the result is assigned to an int variable (C++ won’t)</li>
</ul>
</li>
</ul>
<ul>
<li>Coercion<ul>
<li>Although Java has just half the assignment coercions of C++, its strong typing is still far less effective that that of Ada (or Rust)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Type Equivalence<ul>
<li>When checking for type errors, we need <strong>rules</strong> to tell when two operands have compatible types</li>
<li>The rules for <em>primitive</em> (built-in) types are well understood<ul>
<li>coercion allows types to be compatible rather than equivalent</li>
</ul>
</li>
</ul>
<ul>
<li>For <em>structured</em> types, coercion is rare<ul>
<li>so we are usually interested in type equivalence</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Name Type Equivalence<ul>
<li>Two variables have equivalent types if they are either in the <em>same declaration</em> or in declarations that use the <em>same type name</em></li>
<li>Easy to implement, but highly restrictive:<ul>
<li>Subranges of integer types are <strong>not</strong> equivalent with integer types<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type IndexType is new Integer 1..100; -- Ada code</span><br><span class="line">count : Integer;</span><br><span class="line">index : IndexType;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Formal parameters must be the same type as their corresponding actual parameters – requires global declaration of type names</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Structure Type Equivalence<ul>
<li>Two variables have equivalent types if their types have <em>identical structures</em><ul>
<li>More flexible, but harder to implement</li>
</ul>
</li>
</ul>
<ul>
<li>Name equivalence solves this problem</li>
<li>C and C++ use structural equivalence except for structs, unions, and classes (where name equivalence is used)</li>
</ul>
</li>
</ul>
<h3 id="Chapter-7-Expressions"><a href="#Chapter-7-Expressions" class="headerlink" title="Chapter 7: Expressions"></a>Chapter 7: Expressions</h3><ul>
<li>intro<ul>
<li>Expressions are the <strong>fundamental</strong> means of specifying computations in a programming language</li>
<li><strong>Essence of imperative languages</strong> is the dominant role of assignment statements</li>
</ul>
</li>
</ul>
<ul>
<li>Operators<ul>
<li>Number of operands<ul>
<li>unary</li>
<li>binary</li>
<li>ternary</li>
</ul>
</li>
</ul>
<ul>
<li>notation<ul>
<li>Most languages use <em>infix</em> notation, but some use <em>prefix</em> notation</li>
<li><em>Prefix</em> notation avoids many of the issues of <em>infix</em> notation: no precedence concerns, no associativity concerns, etc.</li>
</ul>
</li>
</ul>
</li>
<li>Conditional Expressions<ul>
<li>C-based languages (e.g., C, C++)</li>
<li>example <code>average = (count == 0) ? 0 : sum / count;</code></li>
</ul>
</li>
</ul>
<ul>
<li><strong>&lt;=&gt;</strong> Spaceship Operator (C++20)<ul>
<li>auto generating &lt;, &lt;=, &gt;, &gt;=, ==, !=<ul>
<li>A class can define <code>operator&lt;=&gt;</code> as defaulted, in which case the compiler will also generate the code for that operator<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Point&amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// ... other non-comparison member functions ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Operand Evaluation Order<ol>
<li><em>Variables</em> - fetch the value from memory</li>
<li><em>Constants</em> - sometimes a fetch from memory; sometimes the constant is in the machine language instruction</li>
<li><em>Parenthesized expressions</em> - evaluate all operands and operators first</li>
<li><em>Function Calls</em> - the most interesting case is when an operand is a function call</li>
</ol>
</li>
</ul>
<ul>
<li>Potentials for Side Effect<ul>
<li><em>Functional side effects</em>: when a function changes one of its parameters or a global variable</li>
<li>Problem: when a function referenced in an expressions alters another operand of the expression</li>
<li>examples<ul>
<li><code>b = a + foo(&amp;a) + a; // assume that foo changes its parameter</code></li>
<li><code>i += i++ + ++i + --i + i--;</code></li>
<li><code>void funct(funct1(), funct2() ..) // we don&#39;t know the order of execution of parameters</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Functional Side Effects<ul>
<li>two possible solutions to the problem</li>
</ul>
<ol>
<li>write the language definition to disallow function aside effects<ul>
<li>no two-way params in functions</li>
<li>no non-local references in functions</li>
<li><em>Good</em> it works</li>
<li><em>bad</em> inflexibility of one-way params and lack of non-local references</li>
</ul>
</li>
<li>Write the language definition to demand that operand evaluation order be fixed<ul>
<li><em>bad</em> Limits some compiler optimizations</li>
<li>Java requires that operands appear to be evaluated in left-to-right order</li>
</ul>
</li>
</ol>
</li>
<li>Referential Transparency<ul>
<li>A program has the property of <strong>“referential transparency”</strong> if any two expressions in the program that have the same value can be substituted for one another anywhere in the program, without affecting the action of the program</li>
<li>example<br>9</li>
<li><em>Good</em>: Semantics of a program is much easier to understand if it has referential transparency</li>
<li>Because they do not have variables, programs in <strong>pure functional languages</strong> are referentially transparent<ul>
<li>Functions cannot have state, which would be stored in local variables</li>
<li>If a function uses an outside value, it must be a constant (there are no variables); so, the value of a function depends only on its parameters</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Overloaded Operators<ul>
<li>Use of an operator for more than one purpose is called <em>operator overloading</em></li>
<li>Some are common (e.g., + for int and float)</li>
<li>Some are potential problems (e.g., * in C and C++)<ul>
<li>Loss of compiler error detection (omission of an operand should be a detectable error; e.g., is “-“ subtraction or negation)</li>
<li>Some loss of readability</li>
<li>Can be avoided by introduction of new symbols (e.g., Pascal’s div for integer division)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Type Conversions<ul>
<li>Narrowing Conversion<ul>
<li>Converts an object to a type that cannot include all of the values of the original type</li>
<li>For example, float to int</li>
</ul>
</li>
<li>Widening Conversion<ul>
<li>An object is converted to a type that can include at least approximations to all of the values of the original type</li>
<li>For example, int to float</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Mixed Mode Expressions<ul>
<li>A <em>mixed-mode expression</em> is one that has operands of different types</li>
<li>A <em>coercion</em> is an implicit type conversion</li>
<li><em>Bad</em> They decrease the compiler’s ability to detect a type error</li>
<li>In most languages, all numeric types are coerced in expressions, using widening conversions</li>
<li>In Ada (or Rust), there are virtually no coercions in expressions</li>
</ul>
</li>
</ul>
<ul>
<li>Explicit Type Conversions<ul>
<li>Called <em>casting</em> in C-based languages</li>
<li>C <code>(int)angle</code></li>
<li>Ada and F#: <code>float(sum)</code> Note that syntax of Ada/F# is similar to that of function calls</li>
</ul>
</li>
</ul>
<ul>
<li>relational expressions<ul>
<li>Use relational operators and operands of various types</li>
<li>Evaluate to some Boolean representation</li>
<li>Coercion on Operands<ul>
<li>eg JavaScript PHP</li>
</ul>
<ul>
<li>== and != will attempt to coerce operands if different types</li>
<li>=== and !== will not</li>
</ul>
</li>
</ul>
</li>
<li>Boolean (Logical) Expressions<ul>
<li>Operands are boolean and the result is boolean</li>
</ul>
</li>
</ul>
<ul>
<li>No boolean Type in C<ul>
<li>C89 has no Boolean type (C99 does has the <code>bool</code> type)</li>
<li>It uses <code>int</code> type with <strong>0</strong> for false and <strong>nonzero</strong> for true</li>
<li>example <code>a &lt; b &lt; c</code><ul>
<li>A legal expression, but the result is not what you might expect</li>
<li>First operator is evaluated, producing 0 or 1</li>
<li>The evaluation result is then compared with the third operand</li>
<li>however this is possible in Python</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Short circuit Evaluation</strong><ul>
<li>An expression in which the result is determined without evaluating all of the operands and/or operators</li>
<li>example <code>(13 * a) * (b / 13 - 1)</code><ul>
<li>if <code>a</code> is 0, there’s no need to evaluate <code>b / 13 - 1</code></li>
<li>a short circuit does not occur here or in arithmetic expressions</li>
</ul>
</li>
</ul>
<ul>
<li>example <code>while((index &lt; length) &amp;&amp; (aList[index] != val))</code></li>
<li>C, C++, Java also provide bitwise Boolean operators that do not short circuit (<code>&amp;</code> and <code>|</code>)</li>
<li>Ada <ul>
<li>Separate operators for short circuiting and no short circuiting</li>
<li>Short-circuit is specified with <code>and then</code> and <code>or else</code><ul>
<li><code>and</code> <code>or</code> won’t support short circuit</li>
</ul>
</li>
</ul>
</li>
<li>Problem / side effects<ul>
<li><code>(a &gt; b) || (b++ / 3)</code> <code>b++</code> does not always occur</li>
</ul>
</li>
</ul>
</li>
<li>Assignment Statements<ul>
<li><strong>Central construct of imperative languages</strong></li>
<li>Change the binding of values to variables</li>
<li><code>=</code> FORTRAN, BASIC, the C-based languages</li>
<li><code>:=</code> ALGOLs, Pascal, Ada</li>
</ul>
</li>
</ul>
<ul>
<li>Conditional Targets<ul>
<li>Example in Perl</li>
<li><code>($flag ? $total : $subtotal) = 0</code> <ul>
<li>equals to<code>if ($flag) &#123; $total = 0 &#125; else &#123; $subtotal = 0 &#125;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Unary Assignment Operators<ul>
<li>Operators in C-based languages that combine increment and decrement operations with assignment</li>
<li><code>count++;</code> <code>++count;</code> <code>sum = ++count;</code> <code>sum = count++;</code></li>
</ul>
<ul>
<li><code>sum = -++count;</code> count incremented then result is negated and assigned<ul>
<li>yikes don’t use forms that are not perfectly clear</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Assignment as an Expression<ul>
<li>In C, C++, and Java, the assignment statement produces a result and can be used as operands</li>
<li>example <code>while ((ch = fin.getchar()) != EOF) &#123; ... &#125;</code><ul>
<li>ch = fin.getchar() is carried out</li>
<li>The result (assigned to ch) is used as a conditional value for the whilestatement</li>
<li>Note: be careful with your use of parentheses – they are required in this case, since assignment has low precedence</li>
</ul>
</li>
</ul>
<ul>
<li>simple mistake <code>if(x = y)...</code><ul>
<li>If the assignment operator did not return a value, then this error is caught at compile time</li>
<li>Java and C#: only allow boolean expressions in their <em>if-statements</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>List Assignments<ul>
<li>Perl, Ruby, Python support list assignments allowing multiple sources and multiple targets, e.g.,<code>($first, $second, $third) = (20, 30, 40);</code></li>
</ul>
<ul>
<li>Allows for single statement swaps, e.g., <code>($first, $second) = ($second, $first);</code></li>
</ul>
</li>
<li>Mixed Mode Expressions<ul>
<li>A <em>mixed-mode expression</em> is one that has operands of different types</li>
<li>A <em>coercion</em> is an implicit type conversion</li>
<li><em>Bad</em> They decrease the compiler’s ability to detect a type error</li>
<li>In most languages, all numeric types are coerced in expressions, using <em>widening</em> conversions</li>
<li>In Ada (or Rust), there are virtually no coercions in expressions</li>
<li>Assignment statements can also be mixed-mode<ul>
<li>example<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a, b;</span><br><span class="line">float c;</span><br><span class="line">c &#x3D; a &#x2F; b;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Fortran, C, and C++: any numeric type value can be assigned to any numeric type variable</li>
<li>Java: only widening assignment coercions are done</li>
<li>Ada (and Rust): there is no assignment coercion</li>
<li>Note: coercions occur <em>after</em> the <em>rhs</em> is evaluated</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-8-Statement-Level-Control"><a href="#Chapter-8-Statement-Level-Control" class="headerlink" title="Chapter 8: Statement Level Control"></a>Chapter 8: Statement Level Control</h3><ul>
<li>Control Statements: Evolution<ul>
<li>FORTRAN I control statements were based directly on IBM 704 hardware</li>
<li>Very simple minded by today’s standards<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (arithmetic-expr) N1, N2, N3</span><br></pre></td></tr></table></figure>
<ul>
<li>N1, N2, N3 are statement labels</li>
<li>Segments require unconditional branch statements (<em>goto-statements</em>)</li>
<li>Selectable statements can be anywhere</li>
<li>Much research and argument in the 1960s about the issue<ul>
<li>One important result: It was proven that all algorithms represented by flowcharts can be coded with only two-way selection and pretest logical loops</li>
<li>GOTO is not essential, and even considered “harmful”<ul>
<li>“Go To Statement Considered Harmful” by Djikstra</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Control Structure<ul>
<li>A control statement and the statements whose execution it controls<ul>
<li>having more than the minimal two increases the writability of a language</li>
<li>Having too many may impact the readability of the language</li>
</ul>
</li>
</ul>
</li>
<li>Selection Statements<ul>
<li>A <em>selection statement</em> provides the means of choosing between two or more paths of execution</li>
<li>general categories<ul>
<li>Two-way selectors (if-statement)</li>
<li>Multiple-way selectors (switch-statement)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>The Control Expression<ul>
<li>If the <code>then</code> reserved word or some other syntactic marker is not used to introduce the <em>then-clause</em>, the control expression is placed in parentheses, however,<ul>
<li>MATLAB does not use the <code>then</code> reserved word and doesn’t require parentheses</li>
<li>In Ruby, the <code>then</code> reserved word is optional</li>
</ul>
</li>
<li>conditional as boolean<ul>
<li>C89, C99, C++, Javascript, MATLAB, Python: The control expression can be arithmetic</li>
<li>Ada, C#, Go, Java, Ruby, Rust: The control expression must be Boolean</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Clause Form</p>
<ul>
<li>In many contemporary languages, the <em>then-clause</em> and <em>else-clause</em> can be single statements or compound statements</li>
<li>Language properties<ul>
<li>Perl, Rust:<ul>
<li>All clauses must be delimited by braces (they must be compound)</li>
</ul>
</li>
<li>Fortran 95, Ada, and Ruby:<ul>
<li>Clauses are statement sequences ending with a reserved word</li>
</ul>
</li>
<li>Python:<ul>
<li>Uses indentation to define clauses</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Multiple-Way Selection Statements</p>
<ul>
<li>Allow the selection of one of any number of statements or statement groups</li>
<li>C, C++, Java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (Expression) &#123;</span><br><span class="line">    case Const_expr1: Stmt1;</span><br><span class="line">    ...</span><br><span class="line">    case Const_exprn: Stmtn;</span><br><span class="line">    [default: Stmtn+1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C</p>
<ul>
<li>Design choices for C’s switch-statement<ol>
<li>Control expression can be only an integral type</li>
<li>Cases must be <strong>compile-time constants</strong></li>
<li>Selectable segments can be statement sequences</li>
<li><em>default-clause</em> is for unrepresented values (if there is no <code>default</code>, the whole statement does nothing)</li>
</ol>
</li>
</ul>
</li>
<li><p>C, C++, Java, Javascript</p>
<ul>
<li>Design choices for C’s switch-statement<ul>
<li>Any number of segments can be executed in one execution of the construct (there is no implicit branch at the end of selectable segments) – thus requiring the use of break at the end of segments where fall-through is not desired<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (index) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">3</span>: odd += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">4</span>: even += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;Value other than 1-4\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>C#</p>
<ul>
<li>Rule<ul>
<li>Differs from C in that C# has a static semantics rule that disallows the implicit execution of more than one section</li>
<li>Each selectable segment must end with an unconditional branch (<code>goto</code> or <code>break</code>)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: Console.WriteLine(<span class="string">&quot;Value is 1.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">3</span>: Console.WriteLine(<span class="string">&quot;Value is 2 or 3&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="keyword">case</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Go</p>
<ul>
<li>Rule<ul>
<li>Only runs the selected case, not all the cases that follow</li>
<li>The <code>break</code> statement that is needed is automatically provided    </li>
</ul>
</li>
</ul>
</li>
<li><p>Ada</p>
<ul>
<li>Similar to Go, Ada’s switch (or case) is more reliable than C’s switch (once a <em>Stmt_sequence</em> execution is completed, control is passed to the first statement after the case statement)</li>
<li>Syntax<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Expression <span class="keyword">is</span></span><br><span class="line">    <span class="keyword">when</span> Choice_list =&gt; Stmt_sequence;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">when</span> Choice_list =&gt; Stmt_sequence;</span><br><span class="line">    [<span class="keyword">when</span> <span class="keyword">others</span> =&gt; Stmt_sequence;]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Ada design choices:<ol>
<li>Expression can be any ordinal type</li>
<li>Segments can be single or compound</li>
<li>Only one segment can be executed per execution of the construct</li>
<li><em>Unrepresented</em> values are not allowed</li>
</ol>
</li>
<li>Choice list forms:<ol>
<li>A single constant</li>
<li>Subranges, 10..15</li>
<li>Boolean OR operators (|); e.g., 10|15|20</li>
</ol>
</li>
<li>Rust has exactly same design choices and Choice list forms</li>
<li>ada/rust must have a default case (since all values of int want to be covered)</li>
</ul>
</li>
<li><p>Multiple-Way Selection Using if</p>
<ul>
<li>Multiple selectors can appear as direct extensions to two-way selectors, using else-if-clauses</li>
</ul>
<ul>
<li>python don’t support switch statement</li>
<li>Ruby can have case statement as <em>range</em> values</li>
</ul>
</li>
<li><p>Switch/case vs. Multi-branch If-statement</p>
<ul>
<li>switch<ul>
<li>In most languages, requires constant cases<ul>
<li>Can be limiting</li>
<li>Can be optimized at compile time via creation of a <strong>jump table</strong></li>
</ul>
</li>
</ul>
</li>
<li>Multi-branch if<ul>
<li>Allows full logical expressions</li>
</ul>
<ul>
<li>Evaluation is one after another until one evaluates to true</li>
</ul>
</li>
</ul>
</li>
<li><p>Iterative Statements</p>
<ul>
<li>The repeated execution of a statement or compound statement</li>
<li>Imperative programming typically -&gt; iteration</li>
<li>Functional programming -&gt; recursion</li>
</ul>
</li>
<li><p>C-based Languages</p>
<ul>
<li><code>for ([expr_1] ; [expr_2] ; [expr_3]) statement</code></li>
<li>The expressions can be whole statements, or even statement sequences, with the statements separated by commas</li>
<li>The value of a multiple-statement expression is the value of the <strong>last statement in the expression</strong> (the 2nd statement)</li>
<li>If the second expression is absent, it is an infinite loop </li>
</ul>
<ul>
<li>There is no explicit loop variable</li>
<li>Everything can be changed in the loop</li>
<li>The first expression is evaluated once, but the other two are evaluated with each iteration</li>
<li>Really just syntactic sugar for a <em>while-loop</em><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// if even, jump into loop</span></span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;top of loop body; i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bottom of loop body; i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C99, C++<ul>
<li>The control expression can also be <code>Boolean</code></li>
<li>The initial expression can include variable definitions<ul>
<li>Scope is from the definition to the end of the loop body </li>
<li>older c has i out of the for loop</li>
</ul>
</li>
</ul>
</li>
<li>C#, Java<ul>
<li>Differs from C++ in that the control expression <em>must</em> be <code>Boolean</code></li>
</ul>
</li>
<li>Python<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop_variable in object:</span><br><span class="line">    Loop_ body</span><br><span class="line">    [else:</span><br><span class="line">        Else_clause]</span><br></pre></td></tr></table></figure></li>
<li>The object is often a range, which is either a list of values in brackets ([2, 4, 6]), or call to <code>range</code> function (<code>range(5)</code>, which returns 0, 1, 2, 3, 4)</li>
<li>The <em>loop_variable</em> takes the values in given range, one for each iteration</li>
<li>The optional <em>Else_clause</em> is executed if the loop terminates normally</li>
<li>Ruby<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">9</span> Statements_using_i <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span>.upto(<span class="number">9</span>) &#123;<span class="params">|i|</span> Statements_using_i&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>For first version, use triple dots to exclude the ending value</li>
<li>The second version works since <em>everything in Ruby is an object</em>, including integers</li>
</ul>
</li>
</ul>
</li>
<li><p>Logically-Controlled Loops</p>
<ul>
<li>Repetition control is based on a Boolean expression<ul>
<li>C, C++: <em>Control_expr</em> can be arithmetic or Boolean</li>
<li>Java: <em>Control_expr</em> must be Boolean</li>
<li>pre-test <code>while()...</code>, post-test <code>do...while()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>User-Located Loop Control Mechanisms</p>
<ul>
<li>Sometimes it is convenient for the programmers to decide a location for loop control (other than top or bottom of the loop)</li>
<li>C, C++, C#, Java, Python, Ruby<ul>
<li>Simple design for single loops (e.g., <code>break</code>)</li>
<li>Unconditional unlabeled exits</li>
</ul>
</li>
</ul>
<ul>
<li>Java Perl<ul>
<li>Unconditional <strong>labeled</strong> exits (<code>break</code> in Java, <code>last</code> in Perl)</li>
<li>Can be used to jump out of a bunch of loops at once</li>
</ul>
</li>
<li>C, C++, Java, Python<ul>
<li>Unlabeled control statement (<code>continue</code>)</li>
<li>Skips the remainder of the current iteration, but does not exit the loop</li>
</ul>
</li>
<li>Java, Perl<ul>
<li><strong>Labeled</strong> versions of <code>continue</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Iteration Based on Data Structures</p>
<ul>
<li>Number of elements in a data structure control loop iteration</li>
<li>Control mechanism is a call to an <em>iterator</em> function that returns the next element in some chosen order, if there is one; else loop is terminated<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = root; p != <span class="literal">nullptr</span>; traverse(p)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// It is the job of traverse() to set p to the next logical element</span></span><br></pre></td></tr></table></figure></li>
<li>C++ STL has iterator type for all container classes</li>
<li>Perl has a built-in iterator for arrays and hashes (foreach)</li>
<li>C#’s foreach statement iterates on the elements of arrays and other collections<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strList = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;Ted&quot;</span>&#125;;</span><br><span class="line">foreach (String name in strList)</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Name: &#123;0&#125;&quot;</span>, name);</span><br><span class="line"><span class="comment">// The notation &#123;0&#125; indicates the position in the string where name will be placed</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Unconditional Branching</p>
<ul>
<li>Transfers execution control to a specified place in the program</li>
<li>Represented one of the most heated debates in 1960’s and 1970’s</li>
<li>Well-known mechanism: goto statement</li>
<li>Major concern: Readability</li>
<li>Some languages do not support goto statement (e.g., Java)</li>
<li>C# offers goto statement (can be used in switch statements)</li>
<li>Loop exit statements (break and continue) are restricted and somewhat camouflaged goto’s</li>
<li>Java has loop break with labels e.g.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label1: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>;;) &#123;</span><br><span class="line">      <span class="keyword">break</span> label1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Chapter-9-Subprograms"><a href="#Chapter-9-Subprograms" class="headerlink" title="Chapter 9: Subprograms"></a>Chapter 9: Subprograms</h3><ul>
<li>chpt 7 within expressions -&gt; chpt 8 among program statements -&gt; chpt 9 among program units</li>
<li>Programming Methodologies Influences<ul>
<li>Late 1960s: people efficiency became important<ul>
<li>structured programming; top-down design and step-wise refinement</li>
<li><em>process abstraction</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Fundamentals of subprograms<ul>
<li>each subprogram has a <em>single entry point</em></li>
<li>the calling program is <em>suspended</em> during execution of the subprogram</li>
<li>Control always <em>returns</em> to the caller when the subprogram terminates</li>
<li>note: these are not true for concurrent programs</li>
</ul>
</li>
</ul>
<ul>
<li>Basic definitions<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subprogram header/ declaration </span></span><br><span class="line"><span class="comment">// in parenthesis: parameter profile / signature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySubprogram</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do some stuff here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subprogram call</span></span><br><span class="line">mySubprogram(<span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>subprogram definition<ul>
<li>describes the interface to and the actions of the subprogram abstraction</li>
</ul>
</li>
</ul>
<ul>
<li>subprogram call<ul>
<li>An explicit request that the subprogram be executed</li>
</ul>
</li>
</ul>
<ul>
<li>Subprogram header / declaration<ul>
<li>The first part of the definition, including the name, the kind of subprogram, the formal parameters, and return type</li>
</ul>
<ul>
<li>function declarations in c and c++ often called <em>prototypes</em></li>
</ul>
</li>
</ul>
<ul>
<li>Parameter profile / signature<ul>
<li>The number, order, and types of its parameters</li>
</ul>
</li>
</ul>
<ul>
<li>subprogram protocol<ul>
<li>The parameter profile and, if it is a function, its return type</li>
</ul>
</li>
</ul>
<ul>
<li>formal parameter<ul>
<li>A dummy variable listed in the subprogram header and used in the subprogram</li>
</ul>
</li>
</ul>
<ul>
<li>Actual parameter / argument<ul>
<li>A value or address used in the subprogram call statement</li>
</ul>
</li>
</ul>
</li>
<li>Actual/Formal Parameter Correspondence<ul>
<li><strong>Positional</strong><ul>
<li>The binding of actual parameters to formal parameters is by position: the first actual parameter is bound to the first formal parameter and so forth</li>
<li><em>Good</em> Safe and effective</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Keyword</strong><ul>
<li>The name of the formal parameter to which an actual parameter is to be bound is specified with the actual parameter</li>
<li><em>Good</em> Parameters can appear in any order, thereby avoiding parameter correspondence errors (useful for lots of parameters)</li>
<li><em>Bad</em> User must know the formal parameter’s names<ul>
<li>if number of formal parameters is greater than actual, we call this coupling</li>
</ul>
</li>
<li><code>subprogram(d = z, c = y, b = x, a = w);</code></li>
<li>Some languages allow you to mix positional and keyword parameters</li>
<li>After the use of the first keyword parameter, only keyword parameters can be used<ul>
<li><code>subprogram(w, x, d = z, y = a);</code> note that after d=z all params afterwards has to be keyword </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Formal Parameter Default Values<ul>
<li>Default values<ul>
<li>In certain languages (e.g., C++, Python, Ruby, Ada, PHP), formal parameters can have default values (if no actual parameter is passed)</li>
<li>(no overloading in python, use default values to overload )</li>
</ul>
</li>
<li>C++<ul>
<li>Default parameters must appear <strong>last</strong>, because parameters are positionally associated</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Variable Numbers of Parameters<ul>
<li>e.g. <code>prinf(&quot;%d, %s&quot;, a, b);</code></li>
</ul>
<ul>
<li>C#<ul>
<li>Accept a variable number of parameters as long as they are of the same type—the corresponding formal parameter is an array preceded by <code>params</code></li>
</ul>
</li>
</ul>
</li>
<li>Two Categories of Subprograms<ul>
<li>Procedure<ul>
<li>A collection of statements that define parameterized computations</li>
<li>They are expected to produce <em>side effects</em></li>
<li>Can return values only by affecting <em>globals or parameters</em></li>
</ul>
</li>
</ul>
<ul>
<li>Function<ul>
<li>Structurally resemble procedures, but are semantically modeled on mathematical functions</li>
<li>They are expected to <em>return a value</em></li>
<li>They are expected to produce <em>no side effects</em></li>
<li> In practice, program functions have side effects</li>
</ul>
</li>
<li>Ada can specify subprograms to be procedure or function</li>
</ul>
</li>
<li>Local Referencing Environments<ul>
<li>Stack-dynamic local variables<ul>
<li><em>good</em> Support for recursion</li>
<li><em>good</em>Storage for locals is shared among some subprograms (related to nested subprograms)</li>
<li><em>bad</em> Allocation/de-allocation, initialization time for each call </li>
<li><em>bad</em> Indirect addressing</li>
<li><em>bad</em> Subprograms cannot be history sensitive</li>
</ul>
</li>
<li>static local variables <ul>
<li>Advantages and disadvantages are the opposite of those for stack- dynamic local variables</li>
</ul>
</li>
</ul>
</li>
<li>Semantic models of parameter passing<ul>
<li>In mode<ul>
<li>Data is received from the actual parameter (e.g. pass-by-value)</li>
</ul>
</li>
<li>Out mode<ul>
<li>Data is returned to the actual parameter (e.g. kind of like Prolog)</li>
</ul>
</li>
</ul>
<ul>
<li>Inout mode<ul>
<li>Data is transferred in both directions (e.g. pass-by-reference, callee can change the value)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Conceptual Models of Transfer<ul>
<li>Used by <strong>pass-by-value</strong> <ul>
<li>Transmit a data value by copying it</li>
</ul>
</li>
<li>Used by <strong>pass-by-reference</strong><ul>
<li>Transmit an access path (a pointer or reference) to the data value</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Pass-by-value (in mode)</p>
<ul>
<li>The value of the actual parameter is used to initialize the corresponding formal parameter</li>
</ul>
<ul>
<li>Normally implemented by copying <ul>
<li>Accesses are more efficient</li>
<li>Copying is cheap for scalars</li>
</ul>
</li>
<li>Can be implemented by transmitting an access path, but not recommended (enforcing write protection is not easy)</li>
<li>disadvantages<ul>
<li>(if by physical move): additional storage is required (stored twice) and the actual move can be costly (for large parameters)</li>
</ul>
<ul>
<li>(if by access path method): must write-protect in the called subprogram and accesses cost more (extra level of indirect addressing)</li>
</ul>
</li>
</ul>
</li>
<li><p>Pass-by-result (out mode)</p>
<ul>
<li>Parameter passed, but no value is transmitted</li>
<li>Corresponding formal parameter acts as a local variable</li>
<li>Its value is transmitted to caller’s actual parameter by physical move</li>
<li>Require extra storage location and copy operation (just like pass-by- value in-mode)</li>
<li>potential problems<ul>
<li><code>sub(x, x);</code> whichever formal parameter is copied back last will represent the current value of <code>x</code></li>
<li><code>sub(list[index], index);</code> do we compute address of <code>list[index]</code> at the beginning of the subprogram or end?</li>
</ul>
</li>
</ul>
<ul>
<li>C# last assigned vale is returned<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x;</span><br><span class="line">DoIt(<span class="keyword">out</span> x, <span class="keyword">out</span> x);</span><br><span class="line"></span><br><span class="line">...DoIt(<span class="keyword">out</span> <span class="built_in">int</span> a, <span class="keyword">out</span> <span class="built_in">int</span> b) &#123;</span><br><span class="line">    b = <span class="number">200</span>; </span><br><span class="line">    a= <span class="number">100</span>; <span class="comment">// x will be 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span>[] list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">97</span>, <span class="number">92</span>, <span class="number">81</span>, <span class="number">60</span>&#125;;</span><br><span class="line">DoIt(<span class="keyword">out</span> list[index], <span class="keyword">out</span> index);</span><br><span class="line"></span><br><span class="line">...DoIt(<span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> <span class="built_in">int</span> y) &#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    y = <span class="number">2</span>; <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after the call index will be 2</span></span><br><span class="line"><span class="comment">// however list becomes &#123;97, 100, 81, 60&#125; list[1] is changed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if we exchange x and y, the result is still the same</span></span><br><span class="line"><span class="comment">// list[index] doesn&#x27;t wait until in the program to change index&#x27;s value - semantics of c#</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>ada can define in out modes through keywords (and in mode will be read-only variable)<ul>
<li>assign value to out mode cause undefined behavior</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Pass-by-Value-Result</strong> (in out mode)</p>
<ul>
<li>A combination of pass-by-value and pass-by-result</li>
<li>values is <strong>copied</strong> in at start and <strong>copied</strong> back at end</li>
<li>sometimes called <em>pass-by-copy</em></li>
<li>formal parameters have local storage</li>
<li>Pros/cons<ul>
<li>Those of pass-by-result</li>
<li>those of pass-by-value</li>
<li>local access (values are there)</li>
</ul>
</li>
</ul>
</li>
<li><p>Pass-by-reference (in out mode)</p>
<ul>
<li>pass an access path(i.e. a pointer or reference)</li>
<li>also called <em>pass-by-sharing</em></li>
</ul>
<ul>
<li>pros/cons<ul>
<li><em>good</em> Passing process is efficient (no copying and no duplicated storage) </li>
<li><em>bad</em> Slower accesses (compared to pass-by-value) to formal parameters due to extra level of indirection</li>
<li><em>bad</em> Unwanted aliases (access broadened)<ul>
<li>The pointers give us additional ways to access a variable (affects readability and thus reliability)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Pass-by-Name (Inout Mode)</p>
<ul>
<li>motivation<ul>
<li>suppose we wanted to calculate sum (x_i * i) from 1 to n</li>
<li>ideally we would write a <code>sum</code> function and call it like this <code>sum(i, 1, n, x[i] * i)</code></li>
</ul>
</li>
</ul>
<ul>
<li>comparison<ul>
<li>with <em>pass-by-value</em>, the expression x[i] * i will be evaluated and the result is passed to the formal parameter</li>
</ul>
<ul>
<li>with <em>pass-by-name</em>, the unevaluated expression is passed to the formal parameter and is evaluated every time the formal parameter is used</li>
</ul>
</li>
</ul>
<ul>
<li>example of sum in ALGOL<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/838079/what-is-pass-by-name-and-how-does-it-work-exactly">pass by name in ALGOL</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">real procedure Sum(j, lo, hi, Ej);</span><br><span class="line">    value lo, hi;</span><br><span class="line">    integer j, lo, hi; real Ej;</span><br><span class="line">begin real S;</span><br><span class="line">    S :&#x3D; 0;</span><br><span class="line">    for j :&#x3D; lo step 1 until hi do</span><br><span class="line">        S :&#x3D; S + Ej;</span><br><span class="line">    Sum :&#x3D; S</span><br><span class="line">end;</span><br><span class="line">...</span><br><span class="line">Sum(i, 1, n, x[i]*i)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li> Assume <code>j</code> and <code>Ej</code> are passed by name</li>
<li> <code>Ej</code> contains the unevaluated expression <code>x[i]*i</code></li>
<li> In the simplest terms, <code>j</code> is replaced by <code>i</code> and <code>Ej</code> is replaced by <code>x[i]*i</code> in the procedure</li>
</ul>
</li>
<li>kind of like passing function</li>
</ul>
</li>
<li><p>Call-by-Name <em>(Not in Text)</em></p>
<ul>
<li>Arguments to functions are not evaluated at all<ul>
<li>rather a <strong>function</strong> is passed </li>
<li>the <em>local environment</em> where the function is defined is captured</li>
<li>whenever the parameter is used, the function is evaluated to produce a value</li>
<li>function is re-evaluated each reference</li>
<li>if the parameter is never used, the function is never evaluated</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Thunk</strong></li>
</ul>
</li>
<li><p>Call-by-Need <em>(Not in Text)</em></p>
<ul>
<li>Call-by-need is a <em>memorized version</em> of call-by-name</li>
<li><em>Memorization</em> - on first reference the function is evaluated and the results is remembered; on subsequent references, the memorized result is returned without re-evaluation of the function</li>
<li>Haskell<ul>
<li>uses call-by-need evaluation</li>
<li>this almost means that the language uses lazy evaluation - nothing gets evaluated until it is needed</li>
<li>Prolog also has memorization<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:- table max2&#x2F;2. % stores </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Eager Evaluation vs. Lazy Evaluation</p>
<ul>
<li>Calling <code>factorial-bad</code> in Racket never terminates<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (my-if-bad x y z)</span><br><span class="line">    (if x y z))</span><br><span class="line">(define (factorial-bad n)</span><br><span class="line">    (my-if-bad (&#x3D; n 0) 1 (* n (factorial-bad (- n 1)))))</span><br></pre></td></tr></table></figure>
<ul>
<li>b.c. of the eager evaluation</li>
</ul>
</li>
</ul>
<ul>
<li>Calling <code>factorial-good</code> n Haskell works<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">my_if_good</span> :: <span class="type">Bool</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span> </span><br><span class="line"><span class="title">my_if_good</span> x y z = <span class="keyword">if</span> x <span class="keyword">then</span> y <span class="keyword">else</span> z</span><br><span class="line"><span class="title">factorial_good</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">factorial_good</span> n = (my_if_good (n == <span class="number">0</span>) <span class="number">1</span> (n * (factorial_good (n - <span class="number">1</span>))))</span><br></pre></td></tr></table></figure>
<ul>
<li>Haskell is lazy evaluation (fix racket version without need of thunk) (delays the evaluation of an expression until its value is needed)</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementing Parameter-Passing Methods</p>
<ul>
<li>In most languages, parameter communication takes place thru the run-time stack<ul>
<li><em>pass-by-reference</em> are the simplest to implement; only an address is placed in the stack</li>
<li><em>Pass-by-value</em> parameters have their values copied into the stack (can be costly for non-scalars)</li>
<li>A subtle, but fatal error can occur with <em>pass-by-reference</em> and <em>pass-by-value-result</em>: a formal parameter corresponding to a constant can mistakenly be changed</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Parameter Passing Methods of Major Languages</strong></p>
<ul>
<li><strong>C</strong><ul>
<li>everything is pass-by-value</li>
<li>pass-by-reference is achieved by using pointers as parameters</li>
</ul>
</li>
</ul>
<ul>
<li><strong>C++</strong><ul>
<li>a special pointer type called reference type fpr pass-by-reference</li>
<li><code>const</code> reference parameters gives us the efficiency of pass-by-reference with safety of pass-by-value</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Java</strong><ul>
<li>all parameters are pass-by-value</li>
<li>the value of object variables is a reference</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Ada</strong><ul>
<li>three semantic modes of parameter transmission: <code>in</code>, <code>out</code>, <code>inout</code> (default: <code>in</code>)</li>
<li>formal parameters declared <code>out</code> can be assigned, but not referenced; those declared <code>in</code> can be referenced, but not assigned; <code>inout</code> parameters can be referenced and assigned</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Fortran 95</strong><ul>
<li>parameters can be declared to be in, out, or inout mode</li>
</ul>
</li>
</ul>
<ul>
<li><strong>C#</strong><ul>
<li>default method: pass-by-value</li>
<li>Pass-by-reference is specified by preceding both a formal parameter and its actual parameter with <code>ref</code></li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>very similar to C#</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Python, Ruby</strong><ul>
<li>Use <strong>pass-by-assignment</strong> where the actual is assigned to the formal (all data values are objects, thus references are passed, but some objects (list/dict in python) are immutable) <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/is-python-call-by-reference-or-call-by-value/">reference</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Type Checking Parameters</p>
<ul>
<li>considered very important for reliability<ul>
<li>Original C, Fortran 77: None</li>
<li>Ada, Fortran 90, Java, Pascal: always required</li>
<li>JavaScript, Perl, PHP: Do not require type checking</li>
<li>ANSI, C, C++: Choice is made by user</li>
<li>Python, Ruby: Variables do not have types (objects do), so parameter type checking is not possible at compile time</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Multidimensional Arrays as Parameters<ul>
<li>If a multi-dimensional array is passed to a subprogram and the subprogram is <em>separately</em> compiled, the compiler needs to know the <em>declared size</em> of that array to build the storage mapping function</li>
<li>Review: For Row Major Order<ul>
<li><code>address(a[i, j]) = address(a[0, 0] + i * number_of_cols + j</code></li>
</ul>
<ul>
<li>assuming element size is one</li>
<li><code>num_of_cols</code> is required</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>C and C++<ul>
<li>Programmer is required to include the declared sizes of all, but the first subscript in actual parameter</li>
<li>disallows writing flexible subprograms<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">    ...</span><br><span class="line">    fun(mat);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>solution: pass a pointer to the array and the sizes of the dimensions as other parameters; the user must include the storage mapping function in terms of the size parameters (in the form of pointer arithmetic)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    *(arr + x * C + y) = <span class="number">3</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">    ...</span><br><span class="line">    fun(mat, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>Java and C#</p>
<ul>
<li>Arrays are objects; they are all <em>single-dimensioned</em>, but the elements can be arrays</li>
<li>each array inherits a name constant (<code>length</code> in Java, <code>Length</code> in C#) that is set to the length of the array when the array object is created</li>
</ul>
</li>
<li><p>Parameters that are subprograms</p>
<ul>
<li><strong>Referencing environment</strong><ul>
<li>when passing subprograms as parameters, we must decide how we are going to <em>bind values to variables</em> in the subprogram when it is invoked</li>
<li>the values bound to variables is known as the <em>referencing environment</em></li>
<li>there are various options that lead to very different semantics</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Shallow Binding</strong><ul>
<li>the environment of the <em>call statement</em> that <em>enacts</em> the passed subprogram</li>
<li>most natural for <strong>dynamic-scoped</strong> languages</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Deep Binding</strong><ul>
<li>The environment of the <em>definition</em> of passed program</li>
<li>most natural for <strong>static-scoped</strong> language</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Ad hoc Binding</strong><ul>
<li>The environment of the <strong>call statement</strong> that <strong>passed</strong> the subprogram<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sub1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">sub2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// pop up a dialog box</span></span><br><span class="line">          <span class="comment">// with value of x</span></span><br><span class="line">          alert(x);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">sub3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">          sub4(sub2);</span><br><span class="line">      &#125;;</span><br><span class="line">      ...</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">sub4</span>(<span class="params">subx</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line">          subx();</span><br><span class="line">        &#125;;</span><br><span class="line">      sub3();</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Shallow binding: Result is 4 </li>
<li>Deep binding: Result is 1 </li>
<li>Ad hoc binding: Result is 3</li>
</ul>
</li>
<li><p>Calling Subprograms Indirectly</p>
<ul>
<li>sometimes subprograms are invoked indirectly</li>
<li>actual function to execute only known at run time</li>
<li>in C and C++, such calls are made through function pointers<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addition is %d\n&quot;</span>, a + b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Subtraction is %d\n&quot;</span>, a - b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Multiplication is %d\n&quot;</span>, a * b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*fun_ptr_arr[])(<span class="keyword">int</span>, <span class="keyword">int</span>) = &#123;add, subtract, multiply&#125;; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ch, a = <span class="number">15</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter Choice: 0 for add, 1 for subtract and 2 &quot;</span> <span class="string">&quot;for multiply\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    (*fun_ptr_arr[ch])(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Design Issues for Functions (<em>that Return Values</em>)</p>
<ul>
<li>What types of return values are allowed?<ul>
<li>most imperative languages restrict return types</li>
</ul>
</li>
</ul>
<ul>
<li>C: Allows any return type, except arrays and functions</li>
</ul>
<ul>
<li>C++: Like C, but also allows user-defined types (classes)</li>
<li>Ada: Allows any return type, but subprograms are not types, so they cannot be returned</li>
<li>C#, Java: <del>Allows any return type, but methods are not types, they cannot be returned</del> They can with lambda expressions </li>
<li>Python Ruby: Methods as first-class objects, so they can be returned, as well as any other class</li>
</ul>
</li>
<li><p>Overloaded Subprograms</p>
<ul>
<li>a subprogram that has the <em>same name</em> as another subprogram in the <em>same referencing environment</em><ul>
<li>Every version of an overloaded subprogram has a unique signature/protocol</li>
<li>choice of which subprogram to call is made at <strong>compile-time</strong></li>
<li>type coercions complicate the task<ul>
<li>(type has to be unique enough such that coercion won’t corrupt functions signature)</li>
</ul>
</li>
</ul>
<ul>
<li>Python has no overloading</li>
</ul>
</li>
</ul>
<ul>
<li>Ada, C, C++, Java<ul>
<li>Include predefined overloaded subprogram</li>
<li>Allow users to write multiple versions of subprograms with the same name</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Generic subprograms<ul>
<li>a <em>generic</em> or <em>polymorphic</em> subprogram takes parameters of different types on different activations</li>
<li>overloaded subprograms provide <em>ad hoc polymorphism</em></li>
<li>a subprogram that takes a generic parameter that is used in a type expression that describes the type of the parameters of the subprogram provides <em>parametric polymorphism</em><ul>
<li>a cheap <strong>compile-time</strong> substitute for dynamic binding</li>
<li>e.g. C++ template functions</li>
</ul>
</li>
<li>In C++, they are instantiated <strong>implicitly</strong>, when the subprogram is named in a call</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Parametric</strong> Polymorphism<ul>
<li>C++</li>
<li>The following template can be instantiated for any type for which operator &gt; is defined, e.g., type <code>int</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">Type <span class="title">max</span><span class="params">(Type first, Type second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first &gt; second ? first : second;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = max(a, b);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Generic Subprograms: Java vs. C++<ul>
<li>Differences between generics in Java 5.0 and C++:<ol>
<li>Generic parameters in Java 5.0 must be classes</li>
<li>Java 5.0 generic methods are instantiated just once as truly generic methods<ul>
<li>Operates on the base Object class</li>
</ul>
</li>
<li>Restrictions can be specified on the classes that can be passed to the generic method as generic parameters<ul>
<li><code>public static &lt;T extends Comparable&gt; T doIt(T[] list) &#123; ... &#125;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>User-Defined Overloaded operators    <ul>
<li>note that in python last definition of overloaded functions will be used</li>
<li>To compute <code>x + y</code>, the interpreter changes it to:<code> x.__add__(y)</code>, thus you only need to define the method to overload the operator<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, second</span>) :</span></span><br><span class="line">    <span class="keyword">return</span> Complex(self.real + second.real,</span><br><span class="line">                    self.imag + second.imag)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Closures<ul>
<li>a <em>closure</em> is a subprogram and the referencing environment where it was defined</li>
<li>the referencing environment is needed if the subprogram can be called from any arbitrary place in the program</li>
<li>to support closures, an implementation may need to provide <em>unlimited extent</em> to some variables (b.c. a subprogram may access a nonlocal variable that is normally no longer alive)</li>
<li>Closures are only needed if a subprogram can access variables in nesting scopes and it can be called from anywhere (a static-scoped language that does not permit nested subprograms doesn’t need closures)</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36636/what-is-a-closure/7464475">closure</a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> add10 makeAdder(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;add 10 to 20: &quot;</span>, add10(<span class="number">20</span>) + <span class="string">&quot;&lt;br /&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;add 5 to 20: &quot;</span> + add5(<span class="number">20</span>), + <span class="string">&quot;&lt;br / &gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-10-Implementing-Subprograms"><a href="#Chapter-10-Implementing-Subprograms" class="headerlink" title="Chapter 10: Implementing Subprograms"></a>Chapter 10: Implementing Subprograms</h3></li>
</ul>
</li>
<li>The general semantics of calls and returns<ul>
<li>the subprogram call and return operations of a language are together called its <em>subprogram linkage</em></li>
</ul>
<ul>
<li>subprogram calls<ul>
<li>the passing of parameters (with various strategies)</li>
<li>allocation of local variables</li>
<li>save the execution status of <em>calling programs</em></li>
<li>transfer of control and arrange for the return</li>
<li>access to nonlocal variables must be arranged if subprograms nested</li>
</ul>
</li>
</ul>
<ul>
<li>subprogram returns<ul>
<li>out mode and inout mode parameters must have their values returned</li>
<li>deallocation of locals</li>
<li>restore the execution status of caller</li>
<li>return control to the caller</li>
</ul>
</li>
</ul>
</li>
<li>Implementing “Simple” Subprograms<ul>
<li>Fortran 77 or earlier<ul>
<li>no nesting of subprograms</li>
<li>local variables are static (no recursion)<ul>
<li><em>compiled-time</em> and <em>static</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>“Simple” subprogram parts<ol>
<li>The actual code (which is static)</li>
<li>the non-code part (local variables and data that can change)<ul>
<li>Activation Record<ul>
<li>Local variables</li>
<li>Parameters</li>
<li>return address</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>activation record<ul>
<li>the format, or layout, of the <strong>non-code part</strong> of an executing subprogram</li>
</ul>
<ul>
<li>an <em>activation record instance</em> is a concrete example of an activation record (the collection of data for a particular subprogram activation)</li>
</ul>
</li>
</ul>
<ul>
<li>the entire memory layout is set at compile time (no recursion support)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>subprograms with stack-dynamic local variables<ul>
<li>The compiler must generate code to cause implicit allocation and deallocation of local variables</li>
<li>required for <strong>recursion</strong> (adds the possibility of multiple simultaneous activations of a subprogram)</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>activation record</strong></p>
<ul>
<li>typical activation record for a language with stack-dynamic local variables (grows with stack)<ul>
<li>local variables</li>
<li>parameters</li>
<li>dynamic link</li>
<li>return address</li>
</ul>
</li>
</ul>
<ul>
<li>the activation record format is <em>static</em> (determined by the compiler), but its size may be dynamic</li>
<li>an activation record instance is <em>dynamically</em> created when a subprogram is called</li>
<li>the <em>Environmental Pointer</em> (EP) must be maintained by the run-time system; it always points at the base of the activation record instance of the currently executing program unit<ul>
<li>stack pointer on top</li>
</ul>
</li>
</ul>
<ul>
<li>The <em>dynamic link</em> points to the bottom of the activation record instance of the caller (the old EP)</li>
<li>Activation record instances reside on the run-time stack</li>
</ul>
</li>
<li><p>Dynamic Chain</p>
<ul>
<li>definition - the collection of <strong>dynamic</strong> links in the stack at a given time (also called <em>call chain</em>) - chain of call</li>
</ul>
</li>
<li><p>example with recursion</p>
<ul>
<li>new field: functional value (will be ? at first since we don’t know the return value yet)</li>
</ul>
</li>
<li><p>Nested Subprograms</p>
<ul>
<li>Ada, Fortran 95, JavaScript, Pascal, Python<ul>
<li>non C-based static-scoped languages that use stack-dynamic local variables and allow subprograms to be nested</li>
<li>we need to provide access to visible non-local variables</li>
<li><em>All variables that can be non locally accessed reside in some activation record instance in the stack</em></li>
</ul>
</li>
</ul>
<ul>
<li>Process of locating a non-local reference<ol>
<li>Find the correct activation record instance (difficult)</li>
<li>determine the correct offset within that activation record instance (easy)</li>
</ol>
</li>
</ul>
</li>
<li><p>Locating a Non-local Reference</p>
<ul>
<li>Static semantics rules <em>guarantee</em> that all non-local variables that can be referenced have been allocated in some activation record instance that is on the stack when the reference is made</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Local Offset</strong><ul>
<li>the offset a local variable form the beginning of the activation record (pointed by the EP)<ul>
<li>can be determined by the compiler at compile time</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Static Scoping <ul>
<li><strong>Static link</strong><ul>
<li> a link in an activation record instance for some subprogram <code>foo</code> that points to most recent activation record instance of <code>foo</code>‘s static parent (the procedure in which <code>foo</code> is nested)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Static Chain</strong><ul>
<li>a chain of static links that connects certain activation record instances</li>
<li>the static chain from an activation record instance connects it to all of its <strong>static ancestors</strong></li>
</ul>
</li>
<li>Static Depth<ul>
<li>an integer associated with a static scope whose value is the depth of nesting of that scope<ul>
<li>how deep is it nested in the outermost scope</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>chain offset<ul>
<li>The chain offset of a nonlocal reference is the difference between the static depth of the reference and that of the scope where it is declared</li>
<li>Also called <em>nesting depth</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># global scope</span><br><span class="line">...</span><br><span class="line">def funct1():</span><br><span class="line">    def funct2():</span><br><span class="line">        def funct3():</span><br><span class="line">            ...</span><br><span class="line">        # end of funct3</span><br><span class="line">        ...</span><br><span class="line">    # end of funct2</span><br><span class="line">    ...</span><br><span class="line"># end of funct1</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>If <code>funct3</code> references a variable declared in <code>funct1</code>, then the <em>chain offset</em> of that reference is 2 (static depth of <code>funct3</code> minus <em>static depth</em> of <code>funct1</code>)</li>
</ul>
</li>
</ul>
<ul>
<li>De Bruijin notation<ul>
<li>A reference to a variable can be represented by the pair:<ul>
<li><code>(chain_offset, local_offset)</code></li>
</ul>
</li>
</ul>
<ul>
<li>where <em>local offset</em> is the offset in the activation record of the variable being referenced (determined by compiler)</li>
</ul>
</li>
</ul>
</li>
<li>Example JavaScript program<ul>
<li>main calls bigsub</li>
<li>bigsub calls sub2</li>
<li>sub2 calls sub3</li>
<li>sub3 calls sub1<ul>
<li>note that sub3 can call sub1 but sub1 cannot call sub3 as sub3 can call any function that’s level one above</li>
<li>can call everything same level as sub2<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bigsub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a, b, c;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sub1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a, d;</span><br><span class="line">            ...</span><br><span class="line">            a = b + c;</span><br><span class="line">        &#125; <span class="comment">// end of sub1</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sub2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b, e;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">sub3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> c, e;</span><br><span class="line">                ...</span><br><span class="line">                sub1();</span><br><span class="line">                e = b + a; </span><br><span class="line">                <span class="comment">// static scoping b comes from sub2,</span></span><br><span class="line">                <span class="comment">// a will comes from bigsub not from sub1 since it can not see anything inside sub1</span></span><br><span class="line">            &#125; <span class="comment">// end of sub3</span></span><br><span class="line">            sub3();</span><br><span class="line">            ...</span><br><span class="line">            a = d + e;</span><br><span class="line">        &#125; <span class="comment">// end of sub2</span></span><br><span class="line">        sub2(<span class="number">7</span>);</span><br><span class="line">    &#125; <span class="comment">// end of bigsub</span></span><br><span class="line">    bigsub();</span><br><span class="line">&#125; <span class="comment">// end of main</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Chapter-10-Continue"><a href="#Chapter-10-Continue" class="headerlink" title="Chapter 10 Continue"></a>Chapter 10 Continue</h3><ul>
<li><p>Review Static Scoping</p>
<ul>
<li>De Bruijn Notation<ul>
<li>a reference to a variable can be represented by the pair: <code>chain_offset, local_offset</code></li>
<li>where <em>local offset</em> is the offset in the activation record of the variable being referenced (determined by compiler)</li>
</ul>
</li>
</ul>
</li>
<li><p>STatic Chain Maintenance</p>
<ul>
<li>at the call<ul>
<li>the activation record instance must be built</li>
<li>the <strong>dynamic</strong> link is just the old environment pointer (EP)</li>
<li>the <strong>static</strong> link must point to the <strong>most recent</strong> ARI of the static parent<ul>
<li>two methods</li>
<li>search the dynamic chain</li>
<li>Treat subprogram calls and definitions like variable references and definitions (offset is known to the compiler); the callee’s static link will be an offset into the caller’s static chain<ul>
<li>look at the nesting depth (subtraction)</li>
<li>where is callee called and where is callee declared<ul>
<li>go down depth of the caller by the subtracted number</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>evaluation of static chains</p>
<ul>
<li>problems<ul>
<li>a nonlocal reference is slow if the nesting depth is large</li>
<li>time-critical code is difficult<ul>
<li>costs of nonlocal references are difficult to determine</li>
<li>Code changes can change the nesting depth, and therefore the cost</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Blocks</p>
<ul>
<li>blocks are user-specified local scopes for variables</li>
<li>the lifetime of <code>temp</code> in example begins when control enters the block</li>
<li>the advantage of using a local variable like <code>temp</code> is that it cannot interfere with any other variable with the same name<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = <span class="built_in">list</span>[upper];</span><br><span class="line">    <span class="built_in">list</span>[upper] = <span class="built_in">list</span>[lower];</span><br><span class="line">    <span class="built_in">list</span>[lower] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>two methods of implementing blocks</p>
<ul>
<li><strong>as separate parameter-less subprograms</strong><ul>
<li>Treat blocks as <em>parameter-less subprograms</em> that are always called from the same location</li>
<li>Every block has an activation record; an instance is created every time the block is executed</li>
<li>Incurs runtime overhead</li>
</ul>
</li>
<li><strong>include space in activation record</strong><ul>
<li>Since the maximum storage required for any block can be statically determined, this <em>amount of space can be statically allocated</em> in the activation record (after the local variables)</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementing Dynamic Scoping: <strong>Deep Access</strong></p>
<ul>
<li>Non-local references are found by searching the activation record instances on the dynamic chain</li>
<li>Length of the chain cannot be statically determined</li>
<li>Every activation record instance must have variable names</li>
</ul>
</li>
<li><p>Implementing Dynamic Scoping: <strong>Shallow Access</strong></p>
<ul>
<li>Put locals in a central place</li>
<li>One stack for each variable name</li>
<li>Central table with an entry for each variable name<ul>
<li>The names in the stack cells indicate the program units of the variable declaration</li>
</ul>
</li>
</ul>
</li>
<li><p>Deep/Shallow Access vs. Deep/Shallow Binding</p>
<ul>
<li>deep and shallow access<ul>
<li>Deep and shallow <em>access</em> are not related to deep and shallow <em>binding</em> (which deal with invoking a subprogram received as a parameter)</li>
</ul>
</li>
<li>deep and shallow binding <ul>
<li>Deep and shallow <em>binding</em> result in different semantics, while deep and shallow <em>access</em> do not</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/BeneneeYu">Projects</a></li>
         
          <li><a href="/miscs/">miscs</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-Languages-Course-Notes"><span class="toc-number">1.</span> <span class="toc-text">Programming Languages Course Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Contents"><span class="toc-number">1.1.</span> <span class="toc-text">Contents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-1-Preliminaries"><span class="toc-number">1.2.</span> <span class="toc-text">Chapter 1: Preliminaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-2-Evolution-of-Major-Programming-Languages"><span class="toc-number">1.3.</span> <span class="toc-text">Chapter 2: Evolution of Major Programming Languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-3-Describe-Syntax"><span class="toc-number">1.4.</span> <span class="toc-text">Chapter 3 Describe Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-5-Names-Bindings-Scopes-Variables"><span class="toc-number">1.5.</span> <span class="toc-text">Chapter 5: Names, Bindings, Scopes (Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-Programing"><span class="toc-number">1.6.</span> <span class="toc-text">Functional Programing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Racket"><span class="toc-number">1.7.</span> <span class="toc-text">Racket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tail-Recursion"><span class="toc-number">1.8.</span> <span class="toc-text">Tail Recursion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Higher-Order-Function-aka-Functional-Form"><span class="toc-number">1.9.</span> <span class="toc-text">Higher Order Function (aka Functional Form)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture"><span class="toc-number">1.10.</span> <span class="toc-text">Lecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-6-Data-Types"><span class="toc-number">1.11.</span> <span class="toc-text">Chapter 6: Data Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prolog"><span class="toc-number">1.12.</span> <span class="toc-text">Prolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More-Prolog-Oct-21-23"><span class="toc-number">1.13.</span> <span class="toc-text">More Prolog (Oct 21 23)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More-Prolog"><span class="toc-number">1.14.</span> <span class="toc-text">More Prolog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-to-Chapter-6-Pointer-and-Reference-Types"><span class="toc-number">1.15.</span> <span class="toc-text">Back to Chapter 6: Pointer and Reference Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Continue-Chapter-6"><span class="toc-number">1.16.</span> <span class="toc-text">Continue Chapter 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-7-Expressions"><span class="toc-number">1.17.</span> <span class="toc-text">Chapter 7: Expressions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-8-Statement-Level-Control"><span class="toc-number">1.18.</span> <span class="toc-text">Chapter 8: Statement Level Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-9-Subprograms"><span class="toc-number">1.19.</span> <span class="toc-text">Chapter 9: Subprograms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-10-Implementing-Subprograms"><span class="toc-number">1.20.</span> <span class="toc-text">Chapter 10: Implementing Subprograms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-10-Continue"><span class="toc-number">1.21.</span> <span class="toc-text">Chapter 10 Continue</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/10/20/Notes-on-Programming-Language/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&text=Notes on Programming Languages"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&is_video=false&description=Notes on Programming Languages"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Notes on Programming Languages&body=Check out this article: http://example.com/2022/10/20/Notes-on-Programming-Language/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&title=Notes on Programming Languages"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/10/20/Notes-on-Programming-Language/&name=Notes on Programming Languages&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/10/20/Notes-on-Programming-Language/&t=Notes on Programming Languages"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2019-2022
    Benjamin Shen
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/BeneneeYu">Projects</a></li><!--
     --><!--
       --><li><a href="/miscs/">miscs</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
